#!/bin/bash
# Copyright (c) 2011, Brian Case
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

have_hdf="@HAVE_HDF@"

###############################################################################
# function to process a zip in a multiband case
###############################################################################

function dozip_multiband {

    local zipfile="$1"
    local tmpdir="$2"
    local ts="$3"
    local origdir="$4"
    
    local file="${zipfile##*/}"
    local ext=$(file_get_extension "$file")
    local base=$(file_get_basename "$file")
    
    local zipinfo="$(zipinfo -1 "${origdir}/${zipfile}")"

    ##### for now we just assume tiff, id like to make this better later #####
    
    local i=0
    local files
    local msband
    
    ##### loop over the subdataset array #####
    
    if [[ ${#subdsnames[@]} == 0 ]]
    then
        local subdsnames=( "" )
    fi
    local sub
    for sub in "${subdsnames[@]}"
    do
        local tmp
        eval tmp=\( \$\{msbands$sub\[@\]\} \)
        local mymsbands=( "${tmp[@]}" )
        unset tmp
        local tmp
        eval tmp=\"\$panband$sub\"
        local mypanband="$tmp"
        unset tmp
        for msband in "${mymsbands[@]}"
        do
            local regex="${msband//./[.]}"
            local regex="${regex//\*/.*}"
            local regex="${regex//\?/.}"

            if grep -i -e "$regex" <<<"$zipinfo" > /dev/null
            then
                local bandfile="$(grep -i -e "$regex" <<<"$zipinfo" | head -n 1)"
                if ! isinarray "$bandfile" "${files[@]}"
                then
                    files[i++]="$bandfile"
                fi
            else
                echo "ERROR: no match in zip for \"$msband\""
                return;
            fi
        
        done
    
        ##### find the pan band #####
        ##### fixme this only assumes 1 posible panband #####
        
        local panfiles
        if [ -n "$mypanband" ]
        then
            
            local regex="${mypanband//./[.]}"
            local regex="${regex//\*/.*}"
            local regex="${regex//\?/.}"
            
            if grep -i -e "$regex" <<<"$zipinfo" > /dev/null
            then
                panfiles[0]="$(grep -i -e "$regex" <<<"$zipinfo" | head -n 1)"
            else
                echo "ERROR: no match in zip for \"$mypanband\""
                return;
            fi
        fi
    
    done
    
    ##### extract the files #####
        
    unzip "${origdir}/${zipfile}" \
           ${files[@]} \
           ${panfiles[@]} \
           -d "$tmpdir" > /dev/null 2> /dev/null || { printerror ; return; }
    
    doimg_multiband "$base" "$tmpdir" "$ts" "no" "${panfiles[0]}" ${files[@]}
    
}

###############################################################################
# function to process a tar in a multiband case
###############################################################################

function dotar_multiband {

    local zipfile="$1"
    local tmpdir="$2"
    local ts="$3"
    local origdir="$4"
    
    local file="${zipfile##*/}"
    local ext=$(file_get_extension "$file")
    local base=$(file_get_basename "$file")
        
    ##### find the 
    case "$ext" in
        
        *tar)
            local switch=""
            ;;
                
        *tar.gz)
            local switch="z"
            ;;
        
        *tgz)
            local switch="z"
            ;;
            
        *tar.bz2)
            local switch="j"
            ;;
    esac
    
    zipinfo="$(tar -t${switch}f "${origdir}/${zipfile}")"

    ##### for now we just assume tiff, id like to make this better later #####
    
    local i=0
    local files
    ##### loop over the subdataset array #####
    
    if [[ ${#subdsnames[@]} == 0 ]]
    then
        local subdsnames=( "" )
    fi
    local sub
    for sub in "${subdsnames[@]}"
    do
        local tmp
        eval tmp=\( \$\{msbands$sub\[@\]\} \)
        local mymsbands=( "${tmp[@]}" )
        unset tmp
        local tmp
        eval tmp=\"\$panband$sub\"
        local mypanband="$tmp"
        unset tmp

        local msband
        for msband in "${mymsbands[@]}"
        do
            local regex="${msband//./[.]}"
            local regex="${regex//\*/.*}"
            local regex="${regex//\?/.}"

            if grep -i -e "$regex" <<<"$zipinfo" > /dev/null
            then
                local bandfile="$(grep -i -e "$regex" <<<"$zipinfo" | head -n 1)"
                if ! isinarray "$bandfile" "${files[@]}"
                then
                    files[i++]="$bandfile"
                fi
            else
                echo "ERROR: no match in zip for \"$msband\""
                return;
            fi
        
        done
    
        ##### find the pan band #####
        ##### fixme this only assumes 1 posible panband #####
        
        local panfiles
        if [ -n "$mypanband" ]
        then
            
            local regex="${mypanband//./[.]}"
            local regex="${regex//\*/.*}"
            local regex="${regex//\?/.}"
            
            if grep -i -e "$regex" <<<"$zipinfo" > /dev/null
            then
                panfiles[0]="$(grep -i -e "$regex" <<<"$zipinfo" | head -n 1)"
            else
                echo "ERROR: no match in zip for \"$mypanband\""
                return;
            fi
        fi
    
    done
        
    ##### extract the files #####
        
    tar -x${switch}f "${origdir}/${zipfile}" \
        -C "$tmpdir" \
        ${files[@]} \
        ${panfiles[@]} > /dev/null 2> /dev/null || { printerror ; return; }
                
    doimg_multiband "$base" "$tmpdir" "$ts" "no" "${panfiles[0]}" ${files[@]}
    
}

###############################################################################
# function to take a list of files on stdin and make a bash array declaration
# script of files with the same basename in each array
# this produces one local array per line named files
###############################################################################'

function find_asoc_files {
    ext=$1
    
    awk -v "ext=$ext" '

BEGIN {
    FS = "\n" ;
}


{
    re = "[.]" ext "$";
        
    names[i++] = $NF;
    if ( $NF ~ re ) {
        split($NF, base, re);
        bases[b++] = base[1];
        images[base[1]] = $NF;
    }

}

END {
    for (ibase in bases) {
        res[1] = bases[ibase] "[.]..[Ww]$";
        res[2] = bases[ibase] ".*[.][Aa][Uu][Xx]$";
        res[3] = bases[ibase] ".*[.][Aa][Uu][Xx][.][Xx][Mm][Ll]$";
        
        i = 0;
        files[i++] = images[bases[ibase]];
        for (iname in names) {
            for ( ire in res ) {
                if ( names[iname] ~ res[ire] ) {
                   files[i++] = names[iname];
                }
            }
        }
        
        printf ( "local files=(" );
        for ( ifile in files ) {
            printf( " \"%s\"", files[ifile] );
        }
        
        printf ( " )\n" );
        for (ifile in files) {
            delete files[ifile];
        }
           
    }
}
'
}

###############################################################################
# function to take a list of files on stdin and make a bash array declaration
# script of files with the same basename in each array
# this produces one local array per line named files
###############################################################################'

function find_asoc_shape_files {
    ext=$1
    
    awk -v "ext=$ext" '

BEGIN {
    FS = "\n" ;
}


{
    re = "[.]" ext "$";
        
    names[i++] = $NF;
    if ( $NF ~ re ) {
        split($NF, base, re);
        bases[b++] = base[1];
        images[base[1]] = $NF;
    }

}

END {
    for (ibase in bases) {
        res[1] = bases[ibase] ".*[.][Dd][Bb][Ff]$";
        res[2] = bases[ibase] ".*[.][Ss][Hh][Xx]$";
        res[3] = bases[ibase] ".*[.][Pp][Rr][Jj]$";
        
        i = 0;
        files[i++] = images[bases[ibase]];
        for (iname in names) {
            for ( ire in res ) {
                if ( names[iname] ~ res[ire] ) {
                   files[i++] = names[iname];
                }
            }
        }
        
        printf ( "local files=(" );
        for ( ifile in files ) {
            printf( " \"%s\"", files[ifile] );
        }
        
        printf ( " )\n" );
        for (ifile in files) {
            delete files[ifile];
        }
           
    }
}
'
}


###############################################################################
# function to process a gzip file
###############################################################################

function dogzip {
    local zipfile="$1"
    local tmpdir="$2"
    local ts="$3"
    local origdir="$4"
    
    local ext=$(file_get_extension "$file")
    local base=$(file_get_basename "$file")
    
    #### extract the files #####
    
    zcat "${origdir}/${zipfile}" > "${tmpdir}/${base}" || { printerror ; return; }
    
    ##### do we have image data? #####

    if ! istrue "$vector"
    then

        ##### check if it is suposed to be multiband #####
        ##### fixme subdsnames could not contain a "" so check the first one and append to msbands #####
        
        if [ -n "$msbands" ]
        then
            local files=( "$base" )
            doimg_multiband "$base" "$tmpdir" \
                            "$ts" "no" "${panfiles[0]}" \
                            ${files[@]}
            
        else
            doimg "$base" "$tmpdir" "$ts" "$(gdalinfo "${tmpdir}/${base}")" "no"
        
        fi

    ##### do we have vector data? #####

    else
        dovector "$base" "$tmpdir" "$ts" "$(ogrinfo -so -al "${tmpdir}/${base}")" "no"

    fi

}

################################################################################
# function to process a gzip file
###############################################################################

function dobzip {
    local zipfile="$1"
    local tmpdir="$2"
    local ts="$3"
    local origdir="$4"
    
    local ext=$(file_get_extension "$file")
    local base=$(file_get_basename "$file")
    
    #### extract the files #####
    
    bzcat "${origdir}/${zipfile}" > "${tmpdir}/${base}" || { printerror ; return; }

    ##### do we have image data? #####

    if ! istrue "$vector"
    then

        ##### check if it is suposed to be multiband #####
        
        if [ -n "$msbands" ]
        then
            local files=( "$base" )
            doimg_multiband "$base" "$tmpdir" \
                            "$ts" "no" "${panfiles[0]}" \
                            ${files[@]}
            
        else
            doimg "$base" "$tmpdir" "$ts" "$(gdalinfo "${tmpdir}/${base}")" "no"
        
        fi

    ##### do we have vector data? #####

    else
        dovector "$base" "$tmpdir" "$ts" "$(ogrinfo -so -al "${tmpdir}/${base}")" "no"

    fi
}


###############################################################################
# function to process a zip file
###############################################################################

function dozip {
    local zipfile="$1"
    local tmpdir="$2"
    local ts="$3"
    local origdir="$4"
    
    ##### check if it is suposed to be multiband #####
    
    if ! istrue "$vector" && [ -n "$msbands" ]
    then
        dozip_multiband "$zipfile" "$tmpdir" "$ts" "$origdir"
        return
    fi
    
    zipinfo=$(zipinfo -1 "${origdir}/${zipfile}")
    
    ##### if exglob is set get a list of those files #####
    
    local regex="${extglob//./[.]}"
    local regex="${regex//\*/.*}"
    local regex="${regex//\?/.}"
    local iext
    
    ##### do we have image data? #####

    if ! istrue "$vector"
    then
        if [ -n "$extglob" ] && grep -i -e "^$regex$" <<<"$zipinfo" > /dev/null
        then
            local firstfile=$(grep -i -e "^$regex$" <<<"$zipinfo" | head -n 1)
            iext="${firstfile##*.}"
    
        ##### tif #####
        
        elif grep -i -e "[.]tif$" <<<"$zipinfo" > /dev/null
        then
            iext="[Tt][Ii][Ff]"

        ##### sid #####
        
        elif grep -i -e "[.]sid$" <<<"$zipinfo" > /dev/null
        then
            iext="[Ss][Ii][Dd]"
        
        ##### jpeg2000 #####
        
        elif grep -i -e "[.]jp2$" <<<"$zipinfo" > /dev/null
        then
            iext="[Jj][Pp]2"
            local images="$(grep -i -e "[.]jp2$" <<<"$zipinfo")"
        
        ##### png #####
        
        elif grep -i -e "[.]png$" <<<"$zipinfo" > /dev/null
        then
            iext="[Pp][Nn][Gg]"
        
        ##### jpg #####
        
        elif grep -i -e "[.]jpg$" <<<"$zipinfo" > /dev/null
        then
            iext="[Jj][Pp][Gg]"
        
        ##### gif #####
        
        elif grep -i -e "[.]gif$" <<<"$zipinfo" > /dev/null
        then
            iext="[Gg][Ii][Ff]"
        
        ##### no match, bail #####
        
        else
            return
        fi
        
        ##### loop over the matching files #####
        
        while read -r line
        do

            eval $line

            ##### extract the files #####
            
            unzip "${origdir}/${zipfile}" \
                  ${files[@]} \
                  -d "$tmpdir" > /dev/null 2> /dev/null || { printerror ; return; }
            
            ##### proccess the images #####
            
            doimg "${files[0]}" "$tmpdir" "$ts" "$(gdalinfo "${tmpdir}/${files[0]}")" "no" || return
        
        done < <( find_asoc_files "$iext" <<<"$zipinfo" )
    
    
    ##### do we have vector data? #####

    else
        
        if [ -n "$extglob" ] && grep -i -e "^$regex$" <<<"$zipinfo" > /dev/null
        then
            local firstfile=$(grep -i -e "^$regex$" <<<"$zipinfo" | head -n 1)
            iext="${firstfile##*.}"

        ##### shp #####
        
        elif grep -i -e "[.]shp$" <<<"$zipinfo" > /dev/null
        then
            iext="[Ss][Hh][Pp]"

        ##### no match, bail #####
        
        else
            return
        fi

        ##### loop over the matching files #####

        while read -r line
        do

            eval $line

            ##### extract the files #####

            unzip "${origdir}/${zipfile}" \
                  ${files[@]} \
                  -d "$tmpdir" > /dev/null 2> /dev/null || { printerror ; return; }

            ##### proccess the vectors #####

            dovector "${files[0]}" "$tmpdir" "$ts" "$(ogrinfo -so -al "${tmpdir}/${files[0]}")" "no" || return

        done < <( find_asoc_shape_files "$iext" <<<"$zipinfo" )

    fi
        
}

###############################################################################
# function to process a tar.gz file
###############################################################################

function dotar {
    local zipfile="$1"
    local tmpdir="$2"
    local ts="$3"
    local origdir="$4"
    
    ##### check if it is suposed to be multiband #####
    
    if ! istrue "$vector" && [ -n "$msbands" ]
    then
        dotar_multiband "$zipfile" "$tmpdir" "$ts" "$origdir"
        return
    fi
        
    local file="${zipfile##*/}"
    local ext=$(file_get_extension "$file")
    local base=$(file_get_basename "$file")
    
    ##### find the 
    case "$ext" in
        
        *tar)
            local switch=""
            ;;
                
        *tar.gz)
            local switch="z"
            ;;
        
        *tgz)
            local switch="z"
            ;;
            
        *tar.bz2)
            local switch="j"
            ;;
    esac
    
    zipinfo="$(tar -t${switch}f "${origdir}/${zipfile}")"
    
    ##### if exglob is set get a list of those files #####
    
    local regex="${extglob//./[.]}"
    local regex="${regex//\*/.*}"
    local regex="${regex//?/.}"
    local iext
    
    ##### do we have image data? #####

    if ! istrue "$vector"
    then

        if [ -n "$extglob" ] && grep -i -e "^$regex$" <<<"$zipinfo" > /dev/null
        then
            local firstfile=$(grep -i -e "^$regex$" <<<"$zipinfo" | head -n 1)
            iext="${firstfile##*.}"
        
        ##### tif #####
        
        elif grep -i -e "[.]tif$" <<<"$zipinfo" > /dev/null
        then
            iext="[Tt][Ii][Ff]"

        ##### sid #####
        
        elif grep -i -e "[.]sid$" <<<"$zipinfo" > /dev/null
        then
            iext="[Ss][Ii][Dd]"
        
        ##### jpeg2000 #####
        
        elif grep -i -e "[.]jp2$" <<<"$zipinfo" > /dev/null
        then
            iext="[Jj][Pp]2"
            local images="$(grep -i -e "[.]jp2$" <<<"$zipinfo")"
        
        ##### png #####
        
        elif grep -i -e "[.]png$" <<<"$zipinfo" > /dev/null
        then
            iext="[Pp][Nn][Gg]"
        
        ##### jpg #####
        
        elif grep -i -e "[.]jpg$" <<<"$zipinfo" > /dev/null
        then
            iext="[Jj][Pp][Gg]"
        
        ##### gif #####
        
        elif grep -i -e "[.]gif$" <<<"$zipinfo" > /dev/null
        then
            iext="[Gg][Ii][Ff]"
        
        ##### no match, bail #####
        
        else
            return
        fi

        ##### loop over the matching files #####
        
        while read -r line
        do

            eval $line

            ##### extract the files #####
            
            tar -x${switch}f "${origdir}/${zipfile}" \
                -C "$tmpdir" \
                ${files[@]} > /dev/null 2> /dev/null || { printerror ; return; }
            
             ##### proccess the images #####
            
            doimg "${files[0]}" "$tmpdir" "$ts" "$(gdalinfo "${tmpdir}/${files[0]}")" "no" || return
            
        done < <( find_asoc_files "$iext" <<<"$zipinfo" )
    
    ##### do we have vector data? #####

    else
        
        if [ -n "$extglob" ] && grep -i -e "^$regex$" <<<"$zipinfo" > /dev/null
        then
            local firstfile=$(grep -i -e "^$regex$" <<<"$zipinfo" | head -n 1)
            iext="${firstfile##*.}"

        ##### shp #####
        
        elif grep -i -e "[.]shp$" <<<"$zipinfo" > /dev/null
        then
            iext="[Ss][Hh][Pp]"

        ##### no match, bail #####
        
        else
            return
        fi

        ##### loop over the matching files #####

        while read -r line
        do

            eval $line

            ##### extract the files #####
            
            tar -x${switch}f "${origdir}/${zipfile}" \
                -C "$tmpdir" \
                ${files[@]} > /dev/null 2> /dev/null || { printerror ; return; }

            ##### proccess the vectors #####

            dovector "${files[0]}" "$tmpdir" "$ts" "$(ogrinfo -so -al "${tmpdir}/${files[0]}")" "no" || return

        done < <( find_asoc_shape_files "$iext" <<<"$zipinfo" )

    fi   
}

###############################################################################
# function to process a kmz file
###############################################################################

function dokmz {
    local zipfile="$1"
    local tmpdir="$2"
    local ts="$3"
    local origdir="$4"
    local f
    
    local file="${zipfile##*/}"
    local ext=$(file_get_extension "$file")
    local base=$(file_get_basename "$file")
    
    for f in $(zipinfo -1 "${origdir}/${zipfile}" "$baseglob.kml")
    do

        ##### extract the kml #####
        
        unzip "${origdir}/${zipfile}" "$f" -d "$tmpdir" || { printerror ; return; }
        
        ##### find and extract the corisponding img #####
        
        local img=$(grep '<GroundOverlay>' -A12 "${tmpdir}/$f" |\
                    grep href | sed -r 's|.*<href>(.*)</href>.*|\1|')
        
        unzip "${origdir}/${zipfile}" "$img" -d "$tmpdir" || { printerror ; return; }
        

        local imgfile="${img##*/}"
        local imgext=$(file_get_extension "$imgfile")
        local imgbase=$(file_get_basename "$imgfile")
        local imgdir=$(file_get_dir "$img")
        
        ##### get the corner quords #####
        
        read n s e w < <(grep '<GroundOverlay>' -A12 "${tmpdir}/$f" |\
                          grep north -A3 |\
                          sed 's:<[/a-z]*>::g' |\
                          tr "\n" " ")
        
        ##### create a vrt with the proj #####
        
        gdal_translate -a_srs EPSG:4326 \
                       -a_ullr $w $n $e $s \
                       -of VRT -mask none \
                       "${tmpdir}/${img}" \
                       "${tmpdir}/${imgdir}/${zipbase}_${imgbase}.vrt" || { printerror ; return; }
        
        ##### proccess #####
        
        doimg "${imgdir}/${zipbase}_${imgbase}.vrt" "$tmpdir" "$ts" \
              "$(gdalinfo "${tmpdir}/${imgdir}/${base}_${imgbase}.vrt")" \
              "no" || return
    done

}



###############################################################################
# function loop over the subdataset array and call a callback function
###############################################################################

function subds_iterator {
    local cbfunc="$1"
    local cbargs=("${@:2}")
    
    ##### if no sub ds names just exec the cb func #####
        
    if [[ ${#subdsnames[@]} == 0 ]]
    then
        "$cbfunc" "${cbargs[@]}" || return
    
    ##### loop over the subdataset array #####
    
    else
    
        local sub
        for sub in "${subdsnames[@]}"
        do
            (
                outdir="${outdir}${sub}"
                dsname="${dsname}${sub}"
                
                local tmp
                eval tmp=\( \$\{msbands$sub\[@\]\} \)
                local msbands=( "${tmp[@]}" )
                unset tmp
                
                local tmp
                eval tmp=\( \$\{msmaskbands$sub\[@\]\} \)
                local msmaskbands=( "${tmp[@]}" )
                unset tmp

                local tmp
                eval tmp=\"\$panband$sub\"
                local panband="$tmp"
                unset tmp
                
                local tmp
                eval tmp=\"\$mscalc$sub\"
                local mscalc="$tmp"
                unset tmp
                
                local tmp
                eval tmp=\"\$lut$sub\"
                local lut="$tmp"
                unset tmp
                
                local tmp
                eval tmp=\"\$msgradient$sub\"
                local msgradient="$tmp"
                unset tmp
                
                "$cbfunc" "${cbargs[@]}" || return
            ) || return
        done
    fi
}
    
###############################################################################
# function to get the pan band from an array of files
###############################################################################

function findpan_cb {
    local files=("${@:1}")
    
    if [ -n "$panband" ]
    then
        find_band_file "$panband" "${files[@]}" || { printerror ; return; }
    fi
}

function findpan {
    local files=("${@:1}")
    
    ##### find the pan band #####
    ##### fixme this only assumes 1 posible panband #####
    
    subds_iterator "findpan_cb" "${files[@]}" | head -n 1
    
}

###############################################################################
# function to get the basename of a ms file
###############################################################################

function getms_base_cb {
    local files=("${@:1}")
    
    if [ -n "$panband" ]
    then
        local msb
        for msb in "${msbands[@]}"
        do
            find_band_file "$msb" "${files[@]}" | sed 's/'"$msb"'.*//'
        done
    fi
}

function getms_base {
    local files=("${@:1}")
    
    ##### find the pan band #####
    ##### fixme this only assumes 1 posible panband #####
    
    subds_iterator "getms_base_cb" "${files[@]}" | head -n 1
    
}

###############################################################################
# function to decide howto deal with a file
###############################################################################

function dofile_sub {
    local file="$1"
    local ext="$2"
    local tmpdir="$3"
    local ts="$4"
    local origdir="$5"
    local files=("${@:6}")
    
    local base=$(file_get_basename "$file")
    
    case "$ext" in
        
        *tar)
            dotar "${file}" "$tmpdir" "$ts" "$origdir"
            ;;
        
        *tar.gz)
            dotar "${file}" "$tmpdir" "$ts" "$origdir"
            ;;
        
        *tgz)
            dotar "${file}" "$tmpdir" "$ts" "$origdir"
            ;;
        
        *tar.bz2)
            dotar "${file}" "$tmpdir" "$ts" "$origdir"
            ;;
        
        bz2)
            dobzip "${file}" "$tmpdir" "$ts" "$origdir"
            ;;
        
        gz)
            dogzip "${file}" "$tmpdir" "$ts" "$origdir"
            ;;
        
        *zip)
            dozip "${file}" "$tmpdir" "$ts" "$origdir"
            ;;
            
        *kmz)
            if ! istrue "$vector"
            then
                dokmz "${file}" "$tmpdir" "$ts" "$origdir"
            fi
            ;;
        
        *hdf)
            if ! istrue "$vector"
            then
                if [ -n "$have_hdf" ]
                then
                    dohdf "${file}" "$tmpdir" "$ts" "$origdir" ${files[@]}
                else
                     printerror "dwh is built without hdf support"
                fi
            fi
            
            ;;
        
        *)

            if ! istrue "$vector"
            then
                if gdalinfo "${origdir}/${file}" > /dev/null
                then
                    
                    ##### check if it is suposed to be multiband #####
    
                    if [ -n "$msbands" ]
                    then
                        
                        ##### get the base name #####
                        
                        doimg_multiband $( getms_base "${files[@]}" ) \
                                        "$tmpdir" \
                                        "$ts" \
                                        "yes" \
                                        $( findpan "${files[@]}" ) \
                                        "${files[@]}"
                    
                    else
                    
                        doimg "${file}" \
                              "$tmpdir" \
                              "$ts" \
                              "$(gdalinfo ${origdir}/$file)" \
                              "yes"
                    
                    fi
                else
                    if ogrinfo "${origdir}/${file}" > /dev/null
                    then
                                
                        dovector "${file}" \
                                 "$tmpdir" \
                                 "$ts" \
                                 "$(ogrinfo -al -so ${origdir}/$file)" \
                                 "yes"
                    fi
                fi
            fi    
            
            ;;
    esac
    
}

###############################################################################
# function to proccess a file
###############################################################################

function dofile {
    myline=$1

    local sourcedir=${indir//\/\///}
    local sourcedir=${sourcedir//\/\///}
    local tmpdir
    local dir=""
    
    tmpdir=$(mktemp -d -p "$tmp" "${dsname}XXXXXXXXXX") || {
        printerror "mktemp"
        echo >&3
        return
    }
    
    ##### new earth explorer #####
    
    if [ -n "$NewEarthExplorer_user" ] && ! istrue "$DWH_REBUILD"
    then
        local file
        file=$( NewEarthExplorer_get "$myline" "$tmpdir" )
        files=$( "$file" )
        
    ##### lftp #####
        
    else
        if ! grep -q -e "^get" <<< "$myline"
        then
            echo >&3
            rm -rf "${tmpdir}"
            return
        fi
    
        ##### make an array of files #####
            
        local i=0
        local files
        local line
        while read line
        do
            files[i++]=$(sed 's:.*/::' <<<"$line" | sed 's/.* -o //')
        done < <( tr ";" "\n" <<<"$myline" )
        
        ##### get the last file name #####
        
        local file="${files[@]:(-1)}"
        
        if ! istrue "$ignoredir" && grep -q -e "$sourcedir/" <<<"$myline"
        then
            dir="$(sed "s|.*$sourcedir/\(.*\) [A-Za-z]*:/.*|\1|" <<<"$myline")/"
        fi
        
        
    fi
    
    local ext=$(file_get_extension "$file")
    local base=$(file_get_basename "$file")
    
    local ts=$(${datefunc} <<< "$myline")
    
    if istrue "$DEBUG_dofile"
    then
        printf " myline=%s\n sourcedir=%s\n file=%s\n base=%s\n ext=%s\n dir=%s\n ts=%s\n" \
               "$myline" \
               "$sourcedir "\
               "$file" \
               "$base" \
               "$ext" \
               "$dir" \
               "$ts"
        echo >&3
        rm -rf "${tmpdir}"
        return
    
    fi

    if istrue "$DWH_REBUILD"
    then
        local origdir="${indir/%\//}.old/${dir}"
        
        ##### link to the main files #####
        
        local f
        for f in "${files[@]}"
        do
            ln -s "${origdir}/${f}" "${tmpdir}/${f}"
        done
                
    else
        local origdir="$tmpdir"
        
        if ! [ -n "$NewEarthExplorer_user" ]
        then
            lftp -e "$(echo "$myline" | sed "s:get \([-]. \)\{1,\}[-/_.A-Za-z0-9]*:get \1${tmpdir}:g") ; exit" > /dev/null 2> /dev/null
        fi
    fi
    
    ##### loop over the subdataset array #####
        
    if [[ ${#subdsnames[@]} == 0 ]]
    then
        local subdsnames=( "" )
    fi
    
    local sub
    for sub in "${subdsnames[@]}"
    do
        (
            outdir="${outdir}${sub}"
            dsname="${dsname}${sub}"
            if ! [ -d "$outdir/${ts}" ]
            then
                 mkdir -p "$outdir/${ts}"
            fi
        )
    done

    dofile_sub "$file" "$ext" "$tmpdir" "$ts" "$origdir" ${files[@]}

    status=$?

    if (($? == 0)) && ! istrue "$DWH_REBUILD"
    then
        
        ##### mv the files to the source dir #####
        
        local f
        for f in "${files[@]}"
        do
            if [ -f "${tmpdir}/${f}" ]
            then
                mv "${tmpdir}/${f}" "${indir}/${dir}${f}"
            fi
        done
        
    fi
    
    rm -rf "${tmpdir}"
    echo >&3
    
    return $status
    
}
