#!/bin/bash
# Copyright (c) 2011, Brian Case
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

###############################################################################
# function to process a zip in a multiband case
###############################################################################

function dozip_multiband {

    local zipfile="$1"
    local tmpdir="$2"
    local ts="$3"
    local origdir="$4"
    
    local file="${zipfile##*/}"
    local base="${file%.*}"
    
    local zipinfo="$(zipinfo -1 "${origdir}/${zipfile}")"

    ##### for now we just assume tiff, id like to make this better later #####
    
    local i=0
    local files
    local msband

    for msband in "${msbands[@]}"
    do
        local regex="${msband//./[.]}"
        local regex="${regex//\*/.*}"
        local regex="${regex//\?/.}"

        if grep -i -e "$regex" <<<"$zipinfo" > /dev/null
        then
            files[i++]="$(grep -i -e "$regex" <<<"$zipinfo" | head -n 1)"
        else
            echo "ERROR: no match in zip for \"$msband\""
            return;
        fi
    
    done
    
    ##### find the pan band #####
    
    local panfiles
    if [ -n "$panband" ]
    then
        
        local regex="${panband//./[.]}"
        local regex="${regex//\*/.*}"
        local regex="${regex//\?/.}"
        
        if grep -i -e "$regex" <<<"$zipinfo" > /dev/null
        then
            panfiles[0]="$(grep -i -e "$regex" <<<"$zipinfo" | head -n 1)"
        else
            echo "ERROR: no match in zip for \"$panband\""
            return;
        fi
    fi
        
    ##### extract the files #####
        
    unzip "${origdir}/${zipfile}" \
           ${files[@]} \
           ${panfiles[@]} \
           -d "$tmpdir" > /dev/null 2> /dev/null || return
    
    doimg_multiband "$base" "$tmpdir" "$ts" "no" "${panfiles[0]}" ${files[@]}
    
}
    
###############################################################################
# function to process a zip file
###############################################################################

function dozip {
    local zipfile="$1"
    local tmpdir="$2"
    local ts="$3"
    local origdir="$4"
    
    ##### check if it is suposed to be multiband #####
    
    if [ -n "$msbands" ]
    then
        dozip_multiband "$zipfile" "$tmpdir" "$ts" "$origdir"
        return
    fi
        
    zipinfo="$(zipinfo -1 "${origdir}/${zipfile}")"
    
    ##### if exglob is set get a list of those files #####
    
    local regex="${pattern//./[.]}"
    local regex="${regex//\*/.*}"
    local regex="${regex//\?/.}"
    
    if [ -n "$extglob" ] && grep -i -e "$regex" <<<"$zipinfo" > /dev/null
    then
        local images="$(grep -i -e "$regex" <<<"$zipinfo")"
    
    ##### tif #####
    
    elif grep -i -e "[.]tif$" <<<"$zipinfo" > /dev/null
    then
        local images="$(grep -i -e "[.]tif$" <<<"$zipinfo")"

    ##### sid #####
    
    elif grep -i -e "[.]sid$" <<<"$zipinfo" > /dev/null
    then
        local images="$(grep -i -e "[.]sid$" <<<"$zipinfo")"
    
    ##### jpeg2000 #####
    
    elif grep -i -e "[.]jp2$" <<<"$zipinfo" > /dev/null
    then
        local images="$(grep -i -e "[.]jp2$" <<<"$zipinfo")"
    
    ##### png #####
    
    elif grep -i -e "[.]png$" <<<"$zipinfo" > /dev/null
    then
        local images="$(grep -i -e "[.]png$" <<<"$zipinfo")"
    
    ##### jpg #####
    
    elif grep -i -e "[.]jpg$" <<<"$zipinfo" > /dev/null
    then
        local images="$(grep -i -e "[.]jpg$" <<<"$zipinfo")"  
    
    ##### gif #####
    
    elif grep -i -e "[.]gif$" <<<"$zipinfo" > /dev/null
    then
        local images="$(grep -i -e "[.]gif$" <<<"$zipinfo")"
    
    ##### no match, bail #####
    
    else
        return
    fi
    
    ##### loop over the matching files #####
    
    local f
    for f in $images
    do
        local imgfile="${f##*/}"
        local imgbase="${imgfile%.*}"
        local imgext="${imgfile##*.}"

        local imgdir="${f%/*}"
        
        if [[ "$imgdir" = "$imgfile" ]]
        then
            local imgdir=""
        else
            if ! grep '\\' <<< "$f" > /dev/null
            then
                local imgdir="${imgdir}/"
            
            ##### if the dir has a backslash use a wildcard for the dir #####
            
            else
                local imgdir=".*"
            fi
        fi
        
        ##### test for world and aux files #####

        local world="$(grep -i -e "${imgdir}${imgbase}[.]..w$" <<<"$zipinfo" | head -n 1)"
        local aux="$(grep -i -e "${imgdir}${imgbase}[.]aux$" <<<"$zipinfo" | head -n 1)"
        local auxxml="$(grep -i -e "${imgdir}${imgbase}[.]aux.xml$" <<<"$zipinfo" | head -n 1)"
        
        ##### use an array for non empty args, zip takes  #####
        ##### non empty args as a pattern and exits false #####
        
        local i=0
        local zipargs
        
        zipargs[i++]="$f"
        if [ -n "$world" ]
        then
            zipargs[i++]="$world"
        fi
        if [ -n "$aux" ]
        then
            zipargs[i++]="$aux"
        fi
        if [ -n "$auxxml" ]
        then
            zipargs[i++]="$auxxml"
        fi
        
        ##### extract the files #####
        
        unzip "${origdir}/${zipfile}" \
              ${zipargs[@]} \
              -d "$tmpdir" > /dev/null 2> /dev/null || return
        
        doimg "$f" "$tmpdir" "$ts" "$(gdalinfo "${tmpdir}/${f}")" "no"

        
    done

}

###############################################################################
# function to process a tar.gz file
###############################################################################

function dotar {
    local zipfile="$1"
    local tmpdir="$2"
    local ts="$3"
    local origdir="$4"
    
    local zipbase="${zipfile%.*}"
    local base2="${base%.*}"
    local ext="${zipfile##*.}"
    local ext2="${zipbase##*.}"
    local ext="$(tr [A-Z] [a-z] <<< "$ext")"
    local ext2="$(tr [A-Z] [a-z] <<< "$ext2")"

    if [[ "$ext2" == "tar" ]]
    then
        ext="${ext2}.${ext}"
        base="$base2"
    fi
    
    ##### find the 
    case "$ext" in
        
        *tar)
            local switch=""
            ;;
                
        *tar.gz)
            local switch=""
            ;;
        
        *tgz)
            local switch=""
            ;;
            
        *tar.bz2)
            local switch=""
            ;;
    esac
    
    zipinfo="$(tar -t${switch}f "${origdir}/${zipfile}")"
    
    ##### if exglob is set get a list of those files #####
    
    local regex="${extglob//./[.]}"
    local regex="${regex//\*/.*}"
    local regex="${regex//?/.}"
    
    if [ -n "$extglob" ] && grep -i -e "$regex" <<<"$zipinfo" > /dev/null
    then
        local images="$(grep -i -e "$regex" <<<"$zipinfo")"
    
    ##### tif #####
    
    elif grep -i -e "[.]tif$" <<<"$zipinfo" > /dev/null
    then
        local images="$(grep -i -e "[.]tif$" <<<"$zipinfo")"

    ##### sid #####
    
    elif grep -i -e "[.]sid$" <<<"$zipinfo" > /dev/null
    then
        local images="$(grep -i -e "[.]sid$" <<<"$zipinfo")"
    
    ##### jpeg2000 #####
    
    elif grep -i -e "[.]jp2$" <<<"$zipinfo" > /dev/null
    then
        local images="$(grep -i -e "[.]jp2$" <<<"$zipinfo")"
    
    ##### png #####
    
    elif grep -i -e "[.]png$" <<<"$zipinfo" > /dev/null
    then
        local images="$(grep -i -e "[.]png$" <<<"$zipinfo")"
    
    ##### jpg #####
    
    elif grep -i -e "[.]jpg$" <<<"$zipinfo" > /dev/null
    then
        local images="$(grep -i -e "[.]jpg$" <<<"$zipinfo")"
    
    ##### gif #####
    
    elif grep -i -e "[.]gif$" <<<"$zipinfo" > /dev/null
    then
        local images="$(grep -i -e "[.]gif$" <<<"$zipinfo")"
    
    ##### no match, bail #####
    
    else
        return
    fi

    ##### loop over the matching files #####
    
    local f
    for f in $images
    do
        local imgfile="${f##*/}"
        local imgbase="${imgfile%.*}"
        local imgext="${imgfile##*.}"
        
        local imgdir="${f%/*}"
        if [[ "$imgdir" = "$imgfile" ]]
        then
            local imgdir=""
        else
            local imgdir="${imgdir}/"
        fi

        ##### test for world and aux files #####

        local world="$(grep -i -e "${imgdir}${imgbase}[.]..w$" <<<"$zipinfo" | head -n 1)"
        local aux="$(grep -i -e "${imgdir}${imgbase}[.]aux$" <<<"$zipinfo" | head -n 1)"
        local auxxml="$(grep -i -e "${imgdir}${imgbase}[.]aux.xml$" <<<"$zipinfo" | head -n 1)"
        
        ##### extract the files #####
        
        tar -x${switch}f "${origdir}/${zipfile}" \
            -C "$tmpdir" \
            "$f" "$world" "$aux" "$auxxml" > /dev/null 2> /dev/null || return
        
        doimg "$f" "$tmpdir" "$ts" "$(gdalinfo "${tmpdir}/${f}")" "no" || return
        
    done
}

###############################################################################
# function to process a kmz file
###############################################################################

function dokmz {
    local zipfile="$1"
    local tmpdir="$2"
    local ts="$3"
    local origdir="$4"
    local f
    
    local zipbase="${zipfile##*/}"
    local zipbase="${zipbase%.*}"
    
    for f in $(zipinfo -1 "${origdir}/${zipfile}" "$baseglob.kml")
    do

        ##### extract the kml #####
        
        unzip "${origdir}/${zipfile}" "$f" -d "$tmpdir" || return
        
        ##### find and extract the corisponding img #####
        
        local img=$(grep '<GroundOverlay>' -A12 "${tmpdir}/$f" |\
                    grep href | sed -r 's|.*<href>(.*)</href>.*|\1|')
        
        unzip "${origdir}/${zipfile}" "$img" -d "$tmpdir" || return
        
        local imgfile="${img##*/}"
        local imgbase="${imgfile%.*}"
        local imgext="${imgfile##*.}"
        
        local imgdir="${img%/*}"
        if [[ "$imgdir" = "$imgfile" ]]
        then
            local imgdir=""
        else
            local imgdir="${imgdir}/"
        fi

        ##### get the corner quords #####
        
        read n s e w < <(grep '<GroundOverlay>' -A12 "${tmpdir}/$f" |\
                          grep north -A3 |\
                          sed 's:<[/a-z]*>::g' |\
                          tr "\n" " ")
        
        ##### create a vrt with the proj #####
        
        gdal_translate -a_srs EPSG:4326 \
                       -a_ullr $w $n $e $s \
                       -of VRT -mask none \
                       "${tmpdir}/${img}" \
                       "${tmpdir}/${imgdir}/${zipbase}_${imgbase}.vrt" || return
                       
        ##### proccess #####
        
        doimg "${imgdir}/${zipbase}_${imgbase}.vrt" "$tmpdir" "$ts" \
              "$(gdalinfo "${tmpdir}/${imgdir}/${zipbase}_${imgbase}.vrt")" \
              "no" || return
    done

}

###############################################################################
# function to proccess a file
###############################################################################

function dofile {
    myline=$1

    if echo "$myline" | grep -e "^get" > /dev/null
    then    
        local sourcedir=${indir//\/\///}
        local sourcedir=${sourcedir//\/\///}
        
        local file="${myline##*/}"

        file=$(sed 's/.* -o //' <<< "$file")
        
        local base="${file%.*}"
        local base2="${base%.*}"
        local ext="${file##*.}"
        local ext2="${base##*.}"
        local ext="$(tr [A-Z] [a-z] <<< "$ext")"
        local ext2="$(tr [A-Z] [a-z] <<< "$ext2")"

        if [[ "$ext2" == "tar" ]]
        then
            ext="${ext2}.${ext}"
            base="$base2"
        fi

        
        #local ext="${ext,,*}"
        
        if [ "$ignoredir" != "yes" ] && echo "$myline" | grep -e "$sourcedir/" > /dev/null
        then
            local dir="$(echo "$myline" | sed "s|.*$sourcedir/\(.*\) [A-Za-z]*:/.*|\1|")/"

        else
            local dir=""
        fi
        
        local ts=$(${datefunc} <<< "$myline")
        
        if [ -n "$DEBUG_dofile" ]
        then
            printf " myline=%s\n sourcedir=%s\n file=%s\n base=%s\n ext=%s\n dir=%s\n ts=%s\n" \
                    "$myline" \
                    "$sourcedir "\
                    "$file" \
                    "$base" \
                    "$ext" \
                    "$dir" \
                    "$ts"
            echo >&3
            return
        fi

        local tmpdir=$(mktemp -d -p "$tmp" "${dsname}XXXXXXXXXX")
        
        
        if [[ "$DWH_REBUILD" == "rebuild" ]]
        then
            local origdir="${indir/%\//}.old/${dir}"
        else
            
            lftp -e "$(echo "$myline" | sed "s:get \([-]. \)\{1,\}[-/_.A-Za-z0-9]*:get \1${tmpdir}:g") ; exit" > /dev/null 2> /dev/null
            local origdir="$tmpdir"
        fi
        

        if ! [ -d "$outdir/${ts}" ]
        then
            mkdir -p "$outdir/${ts}"
        fi
        
        case "$ext" in
        
            *tar)
                dotar "${file}" "$tmpdir" "$ts" "$origdir"
                ;;
                
            *tar.gz)
                dotar "${file}" "$tmpdir" "$ts" "$origdir"
                ;;
            
            *tgz)
                dotar "${file}" "$tmpdir" "$ts" "$origdir"
                ;;
            
            *tar.bz2)
                dotar "${file}" "$tmpdir" "$ts" "$origdir"
                ;;
            
            *zip)
                dozip "${file}" "$tmpdir" "$ts" "$origdir"
                ;;
            
            *kmz)
                dokmz "${file}" "$tmpdir" "$ts" "$origdir"
                ;;

            *)
                if gdalinfo "${origdir}/${file}" > /dev/null
                then
                    

                    ##### hack to make rebuild work here #####
                    
                    if [[ "$DWH_REBUILD" == "rebuild" ]]
                    then
                    
                        ##### link to the main image file #####
                        
                        ln -s "${origdir}/${file}" "${tmpdir}/${file}"
                        
                        ##### if the data has world files and such link them too #####
                        
                        local e
                        for e in ${extra_cp_to_source_ext[@]}
                        do
                            ln -s "${origdir}/${base2}${e}" "${indir}/${dir}/${base2}${e}"
                        done
                    fi

                    doimg "${file}" \
                          "$tmpdir" \
                          "$ts" \
                          "$(gdalinfo ${origdir}/$file)" \
                          "yes"
                fi

            esac
        
        status=$?

        if (($? == 0)) && [[ "$DWH_REBUILD" != "rebuild" ]]
        then
        
            ##### mv the main image file to the source dir #####
            
            mv "${tmpdir}/${file}" "${indir}/${dir}/${file}"
            
            ##### if the data has world files and such mv them too #####
            
            local e
            for e in ${extra_cp_to_source_ext[@]}
            do
                mv "${tmpdir}/${base2}${e}" "${indir}/${dir}/${base2}${e}"
            done
            
        fi

        rm -rf "${tmpdir}"
    
    fi    

    echo >&3
    
    return $status
    
}
