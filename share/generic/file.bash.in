#!/bin/bash
# Copyright (c) 2011, Brian Case
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

have_hdf="@HAVE_HDF@"

###############################################################################
# function to process a zip in a multiband case
###############################################################################

function dozip_multiband {

    local zipfile="$1"
    local tmpdir="$2"
    local ts="$3"
    local origdir="$4"
    
    local file="${zipfile##*/}"
    local base="${file%.*}"
    
    local zipinfo="$(zipinfo -1 "${origdir}/${zipfile}")"

    ##### for now we just assume tiff, id like to make this better later #####
    
    local i=0
    local files
    local msband

    for msband in "${msbands[@]}"
    do
        local regex="${msband//./[.]}"
        local regex="${regex//\*/.*}"
        local regex="${regex//\?/.}"

        if grep -i -e "$regex" <<<"$zipinfo" > /dev/null
        then
            files[i++]="$(grep -i -e "$regex" <<<"$zipinfo" | head -n 1)"
        else
            echo "ERROR: no match in zip for \"$msband\""
            return;
        fi
    
    done
    
    ##### find the pan band #####
    
    local panfiles
    if [ -n "$panband" ]
    then
        
        local regex="${panband//./[.]}"
        local regex="${regex//\*/.*}"
        local regex="${regex//\?/.}"
        
        if grep -i -e "$regex" <<<"$zipinfo" > /dev/null
        then
            panfiles[0]="$(grep -i -e "$regex" <<<"$zipinfo" | head -n 1)"
        else
            echo "ERROR: no match in zip for \"$panband\""
            return;
        fi
    fi
        
    ##### extract the files #####
        
    unzip "${origdir}/${zipfile}" \
           ${files[@]} \
           ${panfiles[@]} \
           -d "$tmpdir" > /dev/null 2> /dev/null || { printerror ; return; }
    
    doimg_multiband "$base" "$tmpdir" "$ts" "no" "${panfiles[0]}" ${files[@]}
    
}

###############################################################################
# function to process a tar in a multiband case
###############################################################################

function dotar_multiband {

    local zipfile="$1"
    local tmpdir="$2"
    local ts="$3"
    local origdir="$4"
    
    local file="${zipfile##*/}"
    local base="${file%.*}"
    local base2="${base%.*}"
    local ext="${zipfile##*.}"
    local ext2="${zipbase##*.}"
    local ext="$(tr [A-Z] [a-z] <<< "$ext")"
    local ext2="$(tr [A-Z] [a-z] <<< "$ext2")"

    if [[ "$ext2" == "tar" ]]
    then
        ext="${ext2}.${ext}"
        base="$base2"
    fi
        
    ##### find the 
    case "$ext" in
        
        *tar)
            local switch=""
            ;;
                
        *tar.gz)
            local switch="z"
            ;;
        
        *tgz)
            local switch="z"
            ;;
            
        *tar.bz2)
            local switch="j"
            ;;
    esac
    
    zipinfo="$(tar -t${switch}f "${origdir}/${zipfile}")"

    ##### for now we just assume tiff, id like to make this better later #####
    
    local i=0
    local files
    local msband

    for msband in "${msbands[@]}"
    do
        local regex="${msband//./[.]}"
        local regex="${regex//\*/.*}"
        local regex="${regex//\?/.}"

        if grep -i -e "$regex" <<<"$zipinfo" > /dev/null
        then
            files[i++]="$(grep -i -e "$regex" <<<"$zipinfo" | head -n 1)"
        else
            echo "ERROR: no match in zip for \"$msband\""
            return;
        fi
    
    done
    
    ##### find the pan band #####
    
    local panfiles
    if [ -n "$panband" ]
    then
        
        local regex="${panband//./[.]}"
        local regex="${regex//\*/.*}"
        local regex="${regex//\?/.}"
        
        if grep -i -e "$regex" <<<"$zipinfo" > /dev/null
        then
            panfiles[0]="$(grep -i -e "$regex" <<<"$zipinfo" | head -n 1)"
        else
            echo "ERROR: no match in zip for \"$panband\""
            return;
        fi
    fi
        
    ##### extract the files #####
        
    tar -x${switch}f "${origdir}/${zipfile}" \
        -C "$tmpdir" \
        ${files[@]} \
        ${panfiles[@]} > /dev/null 2> /dev/null || { printerror ; return; }
                
    doimg_multiband "$base" "$tmpdir" "$ts" "no" "${panfiles[0]}" ${files[@]}
    
}

###############################################################################
# function to take a list of files on stdin and make a bash array declaration
# script of files with the same basename in each array
# this produces one local array per line named files
###############################################################################'

function find_asoc_files {
    ext=$1
    
    awk -v "ext=$ext" '

BEGIN {
    FS = "\n" ;
}


{
    re = "[.]" ext "$";
        
    names[i++] = $NF;
    if ( $NF ~ re ) {
        split($NF, base, re);
        bases[b++] = base[1];
        images[base[1]] = $NF;
    }

}

END {
    for (ibase in bases) {
        res[1] = bases[ibase] "[.]..[Ww]$";
        res[2] = bases[ibase] ".*[.][Aa][Uu][Xx]$";
        res[3] = bases[ibase] ".*[.][Aa][Uu][Xx][.][Xx][Mm][Ll]$";
        
        i = 0;
        files[i++] = images[bases[ibase]];
        for (iname in names) {
            for ( ire in res ) {
                if ( names[iname] ~ res[ire] ) {
                   files[i++] = names[iname];
                }
            }
        }
        
        printf ( "local files=(" );
        for ( ifile in files ) {
            printf( " \"%s\"", files[ifile] );
        }
        
        printf ( " )\n" );
        for (ifile in files) {
            delete files[ifile];
        }
           
    }
}
'
}

###############################################################################
# function to process a zip file
###############################################################################

function dozip {
    local zipfile="$1"
    local tmpdir="$2"
    local ts="$3"
    local origdir="$4"
    
    ##### check if it is suposed to be multiband #####
    
    if [ -n "$msbands" ]
    then
        dozip_multiband "$zipfile" "$tmpdir" "$ts" "$origdir"
        return
    fi
    
    zipinfo=$(zipinfo -1 "${origdir}/${zipfile}")
    
    ##### if exglob is set get a list of those files #####
    
    local regex="${extglob//./[.]}"
    local regex="${regex//\*/.*}"
    local regex="${regex//\?/.}"
    local iext
    
    if [ -n "$extglob" ] && grep -i -e "^$regex$" <<<"$zipinfo" > /dev/null
    then
        local firstfile=$(grep -i -e "^$regex$" <<<"$zipinfo" | head -n 1)
        iext="${firstfile##*.}"
    
    ##### tif #####
    
    elif grep -i -e "[.]tif$" <<<"$zipinfo" > /dev/null
    then
        iext="[Tt][Ii][Ff]"

    ##### sid #####
    
    elif grep -i -e "[.]sid$" <<<"$zipinfo" > /dev/null
    then
        iext="[Ss][Ii][Dd]"
    
    ##### jpeg2000 #####
    
    elif grep -i -e "[.]jp2$" <<<"$zipinfo" > /dev/null
    then
        iext="[Jj][Pp]2"
        local images="$(grep -i -e "[.]jp2$" <<<"$zipinfo")"
    
    ##### png #####
    
    elif grep -i -e "[.]png$" <<<"$zipinfo" > /dev/null
    then
        iext="[Pp][Nn][Gg]"
    
    ##### jpg #####
    
    elif grep -i -e "[.]jpg$" <<<"$zipinfo" > /dev/null
    then
        iext="[Jj][Pp][Gg]"
    
    ##### gif #####
    
    elif grep -i -e "[.]gif$" <<<"$zipinfo" > /dev/null
    then
        iext="[Gg][Ii][Ff]"
    
    ##### no match, bail #####
    
    else
        return
    fi
    
    ##### loop over the matching files #####
    
    while read -r line
    do

        eval $line

        ##### extract the files #####
        
        unzip "${origdir}/${zipfile}" \
              ${files[@]} \
              -d "$tmpdir" > /dev/null 2> /dev/null || { printerror ; return; }
        
        ##### proccess the images #####
        
        doimg "${files[0]}" "$tmpdir" "$ts" "$(gdalinfo "${tmpdir}/${f}")" "no" || return
    
    done < <( find_asoc_files "$iext" <<<"$zipinfo" )
    
}

###############################################################################
# function to process a tar.gz file
###############################################################################

function dotar {
    local zipfile="$1"
    local tmpdir="$2"
    local ts="$3"
    local origdir="$4"
    
    ##### check if it is suposed to be multiband #####
    
    if [ -n "$msbands" ]
    then
        dotar_multiband "$zipfile" "$tmpdir" "$ts" "$origdir"
        return
    fi
        
    local zipbase="${zipfile%.*}"
    local base2="${base%.*}"
    local ext="${zipfile##*.}"
    local ext2="${zipbase##*.}"
    local ext="$(tr [A-Z] [a-z] <<< "$ext")"
    local ext2="$(tr [A-Z] [a-z] <<< "$ext2")"

    if [[ "$ext2" == "tar" ]]
    then
        ext="${ext2}.${ext}"
        base="$base2"
    fi
    
    ##### find the 
    case "$ext" in
        
        *tar)
            local switch=""
            ;;
                
        *tar.gz)
            local switch="z"
            ;;
        
        *tgz)
            local switch="z"
            ;;
            
        *tar.bz2)
            local switch="j"
            ;;
    esac
    
    zipinfo="$(tar -t${switch}f "${origdir}/${zipfile}")"
    
    ##### if exglob is set get a list of those files #####
    
    local regex="${extglob//./[.]}"
    local regex="${regex//\*/.*}"
    local regex="${regex//?/.}"
    local iext
    
    if [ -n "$extglob" ] && grep -i -e "^$regex$" <<<"$zipinfo" > /dev/null
    then
        local firstfile=$(grep -i -e "^$regex$" <<<"$zipinfo" | head -n 1)
        iext="${firstfile##*.}"
    
    ##### tif #####
    
    elif grep -i -e "[.]tif$" <<<"$zipinfo" > /dev/null
    then
        iext="[Tt][Ii][Ff]"

    ##### sid #####
    
    elif grep -i -e "[.]sid$" <<<"$zipinfo" > /dev/null
    then
        iext="[Ss][Ii][Dd]"
    
    ##### jpeg2000 #####
    
    elif grep -i -e "[.]jp2$" <<<"$zipinfo" > /dev/null
    then
        iext="[Jj][Pp]2"
        local images="$(grep -i -e "[.]jp2$" <<<"$zipinfo")"
    
    ##### png #####
    
    elif grep -i -e "[.]png$" <<<"$zipinfo" > /dev/null
    then
        iext="[Pp][Nn][Gg]"
    
    ##### jpg #####
    
    elif grep -i -e "[.]jpg$" <<<"$zipinfo" > /dev/null
    then
        iext="[Jj][Pp][Gg]"
    
    ##### gif #####
    
    elif grep -i -e "[.]gif$" <<<"$zipinfo" > /dev/null
    then
        iext="[Gg][Ii][Ff]"
    
    ##### no match, bail #####
    
    else
        return
    fi

    ##### loop over the matching files #####
    
    while read -r line
    do

        eval $line

        ##### extract the files #####
        
        tar -x${switch}f "${origdir}/${zipfile}" \
            -C "$tmpdir" \
            ${files[@]} > /dev/null 2> /dev/null || { printerror ; return; }
        
         ##### proccess the images #####
        
        doimg "${files[0]}" "$tmpdir" "$ts" "$(gdalinfo "${tmpdir}/${f}")" "no" || return
        
    done < <( find_asoc_files "$iext" <<<"$zipinfo" )
    
}

###############################################################################
# function to process a kmz file
###############################################################################

function dokmz {
    local zipfile="$1"
    local tmpdir="$2"
    local ts="$3"
    local origdir="$4"
    local f
    
    local zipbase="${zipfile##*/}"
    local zipbase="${zipbase%.*}"
    
    for f in $(zipinfo -1 "${origdir}/${zipfile}" "$baseglob.kml")
    do

        ##### extract the kml #####
        
        unzip "${origdir}/${zipfile}" "$f" -d "$tmpdir" || { printerror ; return; }
        
        ##### find and extract the corisponding img #####
        
        local img=$(grep '<GroundOverlay>' -A12 "${tmpdir}/$f" |\
                    grep href | sed -r 's|.*<href>(.*)</href>.*|\1|')
        
        unzip "${origdir}/${zipfile}" "$img" -d "$tmpdir" || { printerror ; return; }
        
        local imgfile="${img##*/}"
        local imgbase="${imgfile%.*}"
        local imgext="${imgfile##*.}"
        
        local imgdir="${img%/*}"
        if [[ "$imgdir" = "$imgfile" ]]
        then
            local imgdir=""
        else
            local imgdir="${imgdir}/"
        fi

        ##### get the corner quords #####
        
        read n s e w < <(grep '<GroundOverlay>' -A12 "${tmpdir}/$f" |\
                          grep north -A3 |\
                          sed 's:<[/a-z]*>::g' |\
                          tr "\n" " ")
        
        ##### create a vrt with the proj #####
        
        gdal_translate -a_srs EPSG:4326 \
                       -a_ullr $w $n $e $s \
                       -of VRT -mask none \
                       "${tmpdir}/${img}" \
                       "${tmpdir}/${imgdir}/${zipbase}_${imgbase}.vrt" || { printerror ; return; }
        
        ##### proccess #####
        
        doimg "${imgdir}/${zipbase}_${imgbase}.vrt" "$tmpdir" "$ts" \
              "$(gdalinfo "${tmpdir}/${imgdir}/${zipbase}_${imgbase}.vrt")" \
              "no" || return
    done

}

###############################################################################
# function to handle a hdf
###############################################################################

function dohdf {
    local lastfile="$1"
    local tmpdir="$2"
    local ts="$3"
    local origdir="$4"
    local files=("${@:5}")
    
    ##### seperate out the geolocation file #####
    
    local dfiles=()
    local i=0
    local file
    for file in "${files[@]}"
    do
        if [[ "$file" == M[OY]D03.* ]]
        then
            local geoloc="$file"
        else
            dfiles[i++]="$file"
        fi
    done
    
    ##### if there is no geoloc file bail #####

    if ! [ -n "$geoloc" ]
    then
        return
    fi

    ##### get a output prefix #####
    
    base="${lastfile#*.}"
    base="${base%.*}"
    base="${base%.*}"
    
    ##### check if its day or night #####
    
    local meta=$(dumpmeta "${tmpdir}/$geoloc" /dev/stdout)
    local daynight=$(grep -e " OBJECT.*DAYNIGHTFLAG" -A4 <<<"$meta" |\
                      grep "VALUE" |\
                      sed 's/.*"\([^"]*\)".*/\1/'
                    )
    
    if istrue "$dayonly" && { [[ "$daynight" != "Day" ]] && [[ "$daynight" != "Both" ]] ; }
    then
        return;
    fi
        
    ##### get the corners of the image #####

    read ulx urx lrx llx < <(grep " OBJECT.*GRINGPOINTLONGITUDE" -A4 <<<"$meta" |\
                              grep VALUE |\
                              sed -e 's/.*[(]\([-.0-9]*\), \([-.0-9]*\), \([-.0-9]*\), \([-.0-9]*\)[)].*/\1 \2 \3 \4/'
                             )


    read uly ury lry lly < <(grep " OBJECT.*GRINGPOINTLATITUDE" -A4 <<<"$meta" |\
                              grep VALUE |\
                              sed -e 's/.*[(]\([-.0-9]*\), \([-.0-9]*\), \([-.0-9]*\), \([-.0-9]*\)[)].*/\1 \2 \3 \4/'
                            )

    read bbe < <(grep " OBJECT.*EASTBOUNDINGCOORDINATE" -A4 <<<"$meta" |\
                   grep VALUE |\
                   sed -e 's/.* \([-.0-9]*\).*/\1/'
                 )
                 
    read bbn < <(grep " OBJECT.*NORTHBOUNDINGCOORDINATE" -A4 <<<"$meta" |\
                   grep VALUE |\
                   sed -e 's/.* \([-.0-9]*\).*/\1/'
                 )
    read bbs < <(grep " OBJECT.*SOUTHBOUNDINGCOORDINATE" -A4 <<<"$meta" |\
                   grep VALUE |\
                   sed -e 's/.* \([-.0-9]*\).*/\1/'
                 )
                 
    read bbw < <(grep " OBJECT.*WESTBOUNDINGCOORDINATE" -A4 <<<"$meta" |\
                   grep VALUE |\
                   sed -e 's/.* \([-.0-9]*\).*/\1/'
                 )

    ##### large change in lon from top to bottom then its over the pole #####

    if { fcmp "$llx - $ulx > 75" || fcmp "$ulx - $llx > 75" ; } && \
        { fcmp "$lrx - $urx > 75" || fcmp "$urx - $lrx > 75" ; }
    then
        #s
        if fcmp "$lly < 0"
        then
            llx=$(fcalc "$llx - 180")
            lrx=$(fcalc "$lrx - 180")
            local t=$llx
            llx=$lrx
            lrx=$t
            if fcmp "$llx < -180"
            then
                llx=$(fcalc "$llx + 360")
            fi
            if fcmp "$lrx < -180"
            then
                lrx=$(fcalc "$lrx + 360")
            fi

            lly=$(fcalc "-180 - $lly")
            lry=$(fcalc "-180 - $lry")
            
        #n
        else
            ulx=$(fcalc "$ulx - 180")
            urx=$(fcalc "$urx - 180")
            local t=$ulx
            ulx=$urx
            urx=$t
            if fcmp "$ulx < -180"
            then
                ulx=$(fcalc "$ulx + 360")
            fi
            if fcmp "$urx < -180"
            then
                urx=$(fcalc "$urx + 360")
            fi

            uly=$(fcalc "180 - $uly")
            ury=$(fcalc "180 - $ury")

        fi
    fi

    ##### count the left corners > 90 #####
    
    local lcount=0
    fcmp "$ulx > 90"
    ((lcount += !$?))
    fcmp "$llx > 90"
    ((lcount += !$?))
    
    ##### count the right corners < -90 #####
    
    local rcount=0
    fcmp "$urx < -90"
    ((rcount += !$?))
    fcmp "$lrx < -90"
    ((rcount += !$?))
    
    ##### if the image has left corners west of the dateline and right      #####
    ##### corners east of the dateline, then the image is over the dateline #####
    
    if ((lcount > 0 && rcount > 0))
    then
        if fcmp "$ulx > 0"
        then
            ulx=$(fcalc "$ulx - 360")
        fi

        if fcmp "$llx > 0"
        then
            llx=$(fcalc "$llx - 360")
        fi
        if fcmp "$urx > 0"
        then
            urx=$(fcalc "$urx - 360")
        fi

        if fcmp "$lrx > 0"
        then
            lrx=$(fcalc "$lrx - 360")
        fi
    fi
    
    ##### find the center of the image #####
    
    local cx=$(fcalc "($llx + $ulx + $urx + $lrx) / 4")
    local cy=$(fcalc "($lly + $uly + $ury + $lry) / 4")
    
    ##### correct for center x < 180 #####
    
    if fcmp "$cx < -180"
    then
        cx=$(fcalc "$cx + 360")
    fi

    ##### fix center of image if its on the other side of the pole #####

    if fcmp "$cy > 90"
    then
        cy=$(fcalc "180 - $cy")
        if fcmp "$cx < 0"
        then
            cx=$(fcalc "$cx + 180")
        else
            cx=$(fcalc "$cx - 180")
        fi
    fi

    if fcmp "$cy < -90"
    then
        cy=$(fcalc "-180 - $cy")
        if fcmp "$cx < 0"
        then
            cx=$(fcalc "$cx + 180")
        else
            cx=$(fcalc "$cx - 180")
        fi
    fi

    ##### get bbox #####
    
    lx=$(fmin $llx $ulx)
    rx=$(fmax $lrx $urx)
    if fcmp "$lx < -180"
    then
        lx=$(fcalc "$lx + 360")
    fi

    uy=$(fmax $uly $ury)
    ly=$(fmin $lly $lry)
    uy=$(fmin $uy 90)
    ly=$(fmax $ly -90)
    
    local oul=()
    local olr=()
    
    ##### need to split into 2 at the dateline? #####
    
    if ((lcount > 0 && rcount > 0))
    then
        oul[0]="${lx},${uy}"
        oul[1]="-180,${uy}"
        olr[0]="180,${ly}"
        olr[1]="${rx},${ly}"

    else
        oul[0]="${lx},${uy}"
        olr[0]="${rx},${ly}"

    fi

    ##### do we need to run crefl? #####
    
    if [ -n "$creflfiles" ]
    then
        if [ -n "$creflbands" ]
        then
            crefl \
                  ${tmpdir}/${creflfiles[0]} \
                  ${tmpdir}/${creflfiles[1]} \
                  ${tmpdir}/${creflfiles[2]} \
                  --bands="$creflbands" \
                  --of="${tmpdir}/crefl.${base}.hdf" > /dev/null || { printerror ; return; }
        else
        
            crefl \
                  ${tmpdir}/${creflfiles[0]} \
                  ${tmpdir}/${creflfiles[1]} \
                  ${tmpdir}/${creflfiles[2]} \
                  --of="${tmpdir}/crefl.${base}.hdf" > /dev/null || { printerror ; return; }
        fi
            
        dfiles=( "crefl.${base}.hdf" )
    fi
    
    ##### loop over the bboxes #####
    
    local ibbox
    for (( ibbox = 0; ibbox < ${#oul[@]} ; ibbox++ ))
    do

        ##### check if the msbands have landmask #####
    
        for msband in "${msbands[@]}"
        do
            if [[ "$msband" == *LandSeaMask* ]]
            then
            
                ##### extract the landmask from the geoloc file #####
            
                swath2grid -if="${tmpdir}/$geoloc" \
                           -of="${tmpdir}/${base}_${ibbox}.tif" \
                           -gf="${tmpdir}/$geoloc" \
                           -off=GEOTIFF_FMT \
                           -oproj=PS \
                           -oprm=0,0,0,0,${cx},${cy} \
                           -oul="${oul[$ibbox]}" \
                           -olr="${olr[$ibbox]}" \
                           -osp=8 \
                           -osst=LAT_LONG \
                           -sds="Land/SeaMask" > /dev/null || { printerror ; return; }
            fi
        done
        
        ##### make tiffs from the dfiles #####
            
        local dfile
        for dfile in "${dfiles[@]}"
        do

            if ! [ -n "$creflfiles" ]
            then
            
                ##### figure out what bands to extract #####

                local meta=$(dumpmeta "${tmpdir}/$dfile" /dev/stdout)

                ##### find the sds base names #####
                
                local bandbases=$(grep -e "OBJECT=DataField" -A4 <<<"$meta" |\
                                   grep -e DataFieldName |\
                                   sed 's/.*"\([^"]*\)".*/\1/'
                                  )
                
                ##### loop over the product band list to build an array of bands for this dataset #####
                
                
                local ofiles=()
                local msband
                local sds=""
                
                ##### loop over the sds base names #####
                
                for bandbase in $bandbases
                do
                    ##### loop over the msbands #####
                    local bands=( )
                    for msband in "${msbands[@]}"
                    do
                        ##### is the sds base name in the msband name? #####
                    
                        if [[  "$msband" == ${bandbase}* ]]
                        then
                            local bnum=$(sed -e "s/${bandbase}_b//" <<<"$msband")
                            bands[$bnum]=1
                        fi
                    done
                
                    ##### is there any matching bands to do in this dataset? #####
                    
                    if [ -n "${!bands[*]}" ]
                    then
                    
                        ##### build a comma delim list of bands #####

                        local bandlist=""
                        local indices=(${!bands[*]})
                        for (( i = 0 ; i <= ${indices[@]:(-1)} ; i++ ))
                        do
                            bandlist="$bandlist,${bands[$i]}"
                        done
                        
                        ##### add the basename and list to the sds list #####
                        
                        if [ -n "$sds" ]
                        then
                            sds="${sds}; ${bandbase}${bandlist}"
                        else
                            sds="${sds}${bandbase}${bandlist}"
                        fi
                    
                    elif [[  "$msband" == "${bandbase}" ]]
                    then
                        ##### add the basename and list to the sds list #####
                        
                        if [ -n "$sds" ]
                        then
                            sds="${sds}; ${bandbase}"
                        else
                            sds="${sds}${bandbase}"
                        fi
                     fi
                done
            fi
            
            if [ -n "$sds" ]
            then
            
                swath2grid -if="${tmpdir}/${dfile}" \
                           -of="${tmpdir}/${base}_${ibbox}.tif" \
                           -gf="${tmpdir}/$geoloc" \
                           -off=GEOTIFF_FMT \
                           -oproj=PS \
                           -oprm=0,0,0,0,${cx},${cy} \
                           -oul="${oul[$ibbox]}" \
                           -olr="${olr[$ibbox]}" \
                           -osp=8 \
                           -osst=LAT_LONG \
                           -sds="$sds" > /dev/null || { printerror ; return; }
                
            else
                
                swath2grid -if="${tmpdir}/${dfile}" \
                           -of="${tmpdir}/${base}_${ibbox}.tif" \
                           -gf="${tmpdir}/$geoloc" \
                           -off=GEOTIFF_FMT \
                           -oproj=PS \
                           -oprm=0,0,0,0,${cx},${cy} \
                           -oul="${oul[$ibbox]}" \
                           -olr="${olr[$ibbox]}" \
                           -osp=8 \
                           -osst=LAT_LONG > /dev/null || { printerror ; return; }
            fi
            

        done

        ##### make an aray of the msband files needed to build the product #####

        i=0
        local flisting=$(find "${tmpdir}/" -name "${base}_${ibbox}*.tif")
        local msband
        local ofiles=()
        for msband in "${msbands[@]}"
        do
            local regex="${msband//./[.]}"
            local regex="${regex//\*/.*}"
            local regex="${regex//\?/.}"

            if grep -i -e "$regex" <<<"$flisting" > /dev/null
            then
                ofiles[i++]="$(grep -i -e "$regex" <<<"$flisting" | \
                                sed 's:.*/::' | \
                                head -n 1)"
            else
                echo "ERROR: no match in hdf for \"$msband\""
                return;
            fi

        done

        ##### translate the nodata values to 0 #####

        i=0
        local ofile
        local vfiles=()
        for ofile in "${ofiles[@]}"
        do
            obase="${ofile%.*}"
            
            local type=$(gdalinfo "${tmpdir}/${ofile}" | grep "Type=" | sed 's/.*Type=\(\w*\).*/\1/' | head -n 1)
            if [[ type == "Int16" ]]
            then
                local nodatav=-32768
            else
                local nodatav=65535
            fi            
            
            gdalwarp -srcnodata $nodatav -wo INIT_DEST=0 -of VRT \
                     "${tmpdir}/${ofile}" \
                     "${tmpdir}/${obase}.vrt" > /dev/null || { printerror ; return; }

            vfiles[i++]="${obase}.vrt"
        done

        doimg_multiband "${base}_${ibbox}" "$tmpdir" "$ts" "no" "" ${vfiles[@]}

    done
}

###############################################################################
# function to proccess a file
###############################################################################

function dofile {
    myline=$1

    if echo "$myline" | grep -e "^get" > /dev/null
    then    
        local sourcedir=${indir//\/\///}
        local sourcedir=${sourcedir//\/\///}
        
        ##### make an array of files #####
        
        local i=0
        local files
        local line
        while read line
        do
            files[i++]=$(sed 's:.*/::' <<<"$line" | sed 's/.* -o //')
        done < <( tr ";" "\n" <<<"$myline" )
        
        ##### get the last file name #####
        
        local file="${files[@]:(-1)}"
        
        local base="${file%.*}"
        local base2="${base%.*}"
        local ext="${file##*.}"
        local ext2="${base##*.}"
        local ext="$(tr [A-Z] [a-z] <<< "$ext")"
        local ext2="$(tr [A-Z] [a-z] <<< "$ext2")"

        if [[ "$ext2" == "tar" ]]
        then
            ext="${ext2}.${ext}"
            base="$base2"
        fi

        
        #local ext="${ext,,*}"
        
        if [ "$ignoredir" != "yes" ] && echo "$myline" | grep -e "$sourcedir/" > /dev/null
        then
            local dir="$(echo "$myline" | sed "s|.*$sourcedir/\(.*\) [A-Za-z]*:/.*|\1|")/"

        else
            local dir=""
        fi
        
        local ts=$(${datefunc} <<< "$myline")
        
        if istrue "$DEBUG_dofile"
        then
            printf " myline=%s\n sourcedir=%s\n file=%s\n base=%s\n ext=%s\n dir=%s\n ts=%s\n" \
                    "$myline" \
                    "$sourcedir "\
                    "$file" \
                    "$base" \
                    "$ext" \
                    "$dir" \
                    "$ts"
            echo >&3
            return
        fi

        local tmpdir
        tmpdir=$(mktemp -d -p "$tmp" "${dsname}XXXXXXXXXX") || { printerror ; return; }
        
        
        if [[ "$DWH_REBUILD" == "rebuild" ]]
        then
            local origdir="${indir/%\//}.old/${dir}"

            ##### link to the main files #####
                        
            local f
            for f in "${files[@]}"
            do
                ln -s "${origdir}/${f}" "${tmpdir}/${f}"
            done
            
        else
            
            lftp -e "$(echo "$myline" | sed "s:get \([-]. \)\{1,\}[-/_.A-Za-z0-9]*:get \1${tmpdir}:g") ; exit" > /dev/null 2> /dev/null
            local origdir="$tmpdir"
        fi
        

        if ! [ -d "$outdir/${ts}" ]
        then
            mkdir -p "$outdir/${ts}"
        fi
        
        case "$ext" in
        
            *tar)
                dotar "${file}" "$tmpdir" "$ts" "$origdir"
                ;;
                
            *tar.gz)
                dotar "${file}" "$tmpdir" "$ts" "$origdir"
                ;;
            
            *tgz)
                dotar "${file}" "$tmpdir" "$ts" "$origdir"
                ;;
            
            *tar.bz2)
                dotar "${file}" "$tmpdir" "$ts" "$origdir"
                ;;
            
            *zip)
                dozip "${file}" "$tmpdir" "$ts" "$origdir"
                ;;
            
            *kmz)
                dokmz "${file}" "$tmpdir" "$ts" "$origdir"
                ;;

            *hdf)
                if [ -n "$have_hdf" ]
                then
                    dohdf "${file}" "$tmpdir" "$ts" "$origdir" ${files[@]}
                else
                    printerror "dwh is built without hdf support"
                fi
                    
                ;;
            
            *)
                if gdalinfo "${origdir}/${file}" > /dev/null
                then
                    
                    doimg "${file}" \
                          "$tmpdir" \
                          "$ts" \
                          "$(gdalinfo ${origdir}/$file)" \
                          "yes"
                fi

            esac
        
        status=$?

        if (($? == 0)) && [[ "$DWH_REBUILD" != "rebuild" ]]
        then
            
            ##### mv the files to the source dir #####
            
            local f
            for f in "${files[@]}"
            do
                if [ -f "${tmpdir}/${f}" ]
                then
                    mv "${tmpdir}/${f}" "${indir}/${mydir}/${f}"
                fi
            done

        fi

        #rm -rf "${tmpdir}"
    
    fi    

    echo >&3
    
    return $status
    
}
