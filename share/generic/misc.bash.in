#!/bin/bash
# Copyright (c) 2011, Brian Case
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

###############################################################################
# function to test for true
###############################################################################

function istrue {
    
   case "$1" in
        [nN][oO])
            false
            ;;
        [yY][eE][sS])
            true
            ;;
        [fF][aA][lL][sS][eE])
            false
            ;;
        [tT][rR][uU][eE])
            true
            ;;
        *)
            ##### if there is a second numeric arg return it by itself,#####
            ##### otherwise return the default of false #####
            
            if [ -n "$2" ]
            then
                return $2
            else
                false
            fi
            ;;
    esac
    
}
###############################################################################
# to remove dupe /'s from a path
###############################################################################

function fixpath {

    sed -r 's|[/]+|/|g' <<<"$1"
}

###############################################################################
# function to get the extent of the ds
###############################################################################

function getextent {
    ts="$1"

    ogrinfo -so -al "${outdir}/${dsname}${ts}.shp" |\
     grep Extent: |\
     sed -e 's/) - (/ /' -e 's/Extent: (//' -e 's/,//g' -e 's/)//'
}

###############################################################################
# min a b
###############################################################################

function fmin {
    
    bc << EOF
scale=20;
define min(a,b) {
    if (a < b) return a;
    return b;
}
min($1, $2)
EOF
}

###############################################################################
# max a b
###############################################################################

function fmax {
    
    bc << EOF
scale=20;
define max(a,b) {
    if (a > b) return a;
    return b;
}
max($1, $2)
EOF
}

###############################################################################
# frontend to bc for calcing floats
###############################################################################

function fcalc {

    if [[ $# -gt 0 ]]
    then
        echo "scale=20; $*" | bc -q 2>/dev/null
    fi
}
    
###############################################################################
# frontend to bc for compareing floats
###############################################################################

function fcmp {

    local cond=0
    if [[ $# -gt 0 ]]
    then
        cond=$(echo "$*" | bc -q 2>/dev/null)
        if [[ -z "$cond" ]]
        then
            cond=0
        fi
        if [[ "$cond" != 0  &&  "$cond" != 1 ]]
        then
            cond=0
        fi
    fi
    local res=$((cond == 0))
    return $res
}

###############################################################################
# convert sci noteation to dec
###############################################################################

function fsci2dec {
    
    fcalc $(sed 's/e[+]*/*10^/g' <<< "$1")
}
    
###############################################################################
# function to get a ts from a lftp command
###############################################################################

function dodate {
    sed -e 's:.*/AE00N[0-9]\{2\}_[a-zA-Z0-9]\{10\}_[0-9]\{6\}\([0-9]\{8\}\).*:\1:' \
        -e 's:.*/LS[0-9]\{8\}\([0-9]\{8\}\).*:\1:' \
        -e 's:.*/AST_L1[AB]E_[0-9]\{3\}_\([0-9]\{4\}\)\([0-9]\{4\}\).*:\2\1:' \
        -e 's:.*/AST_L1B_[0-9]\{3\}\([0-9]\{4\}\)\([0-9]\{4\}\).*:\2\1:' \
        -e 's:.*/EO01[NS][0-9]*_[0-9]*[EW][0-9]*_[0-9]\{6\}\([0-9]\{8\}\).*:\1:'
}

###############################################################################
# function to get the a list of new files
###############################################################################

function getlist {
    local mirrorfile="$1"
    local pattern="$2"
    
    ##### get the list of files on the site #####
    
    mirrorscript="$(lftp "$baseurl" -e "mirror --just-print ; exit")"
    
    ##### if pattern is set get a list of those files #####

    local regex="${pattern//./[.]}"
    local regex="${regex//\*/.*}"
    local regex="${regex//\?/.}"
    
    if [ -n "$pattern" ] 
    then
        if grep -i -e "$regex" <<<"$mirrorscript" > /dev/null
        then
            local files="$(grep -i -e "$regex" <<<"$mirrorscript")"
        else
            return
        fi
    
    ##### tif #####
    
    elif grep -i -e "[.]tif$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]tif$" <<<"$mirrorscript")"

    ##### zip #####
    
    elif grep -i -e "[.]zip$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]zip$" <<<"$mirrorscript")"
        local isarchive="yes"
        
    ##### tar.gz #####
    
    elif grep -i -e "[.]tar.gz$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]tar.gz$" <<<"$mirrorscript")"
        local isarchive="yes"
        
        
    ##### tgz #####
    
    elif grep -i -e "[.]tgz$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]tgz$" <<<"$mirrorscript")"
        local isarchive="yes"
        
    ##### tar.bz2 #####
    
    elif grep -i -e "[.]tar.bz2$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]tar.bz2$" <<<"$mirrorscript")"
        local isarchive="yes"
        
    ##### tar #####
    
    elif grep -i -e "[.]tar$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]tar$" <<<"$mirrorscript")"
        local isarchive="yes"
        
    ##### jpeg2000 #####
    
    elif grep -i -e "[.]jp2$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]jp2$" <<<"$mirrorscript")"
    
    ##### png #####
    
    elif grep -i -e "[.]png$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]png$" <<<"$mirrorscript")"
    
    ##### jpg #####
    
    elif grep -i -e "[.]jpg$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]jpg$" <<<"$mirrorscript")"
    
    ##### gif #####
    
    elif grep -i -e "[.]gif$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]gif$" <<<"$mirrorscript")"
    
    ##### no match, bail #####
    
    else
        return
    fi
    
    ##### add the mkdir commands to the mirrorfile first #####
    
    grep -e "^mkdir" <<<"$mirrorscript" > "$mirrorfile"
    
    ##### loop over the list of files to fetch #####
    
    local line
    while read line 
    do
    
        local file="${line##*/}"

        local base="${file%.*}"
        local base2="${base%.*}"
        local ext="${file##*.}"
        if [[ "$isarchive" = "yes" ]]
        then
            echo "$line"
        else
            
            ##### test for world and aux files #####

            local world="$(grep -i -e "${sdir}${base}[.]..w$" <<<"$mirrorscript" | head -n 1)"
            local aux="$(grep -i -e "${sdir}${base}[.]aux$" <<<"$mirrorscript" | head -n 1)"
            local auxxml="$(grep -i -e "${sdir}${base}[.]aux.xml$" <<<"$mirrorscript" | head -n 1)"
        
            if [ -n "$world" ]
            then
                echo -n "$world ; "
            fi
            
            if [ -n "$aux" ]
            then
                echo -n "$aux ; "
            fi
            
            if [ -n "$auxxml" ]
            then
                echo -n "$auxxml ; "
            fi
            
            echo "$line"
        fi >> "$mirrorfile"
        
    done <<<"$files"
            
    
}





function dotc_old {

(
    for map in $(find $outdir -name "*.map" | sort )
    do
        if istrue "$doovr" 1
        then
            layer=$(grep "$map" -e GROUP | cut -d "'" -f 2 | uniq )
        else
            layer=$(grep "$map" -e NAME  | cut -d "'" -f 2 | uniq )
        fi
        
        cat << EOF

[${layer}]
type=WMS
url=${urlcgibin}?
layers=${layer}
extension=png
tms_type=google
levels=24
spherical_mercator=true

EOF

    done
) > ${basedir}/${dsname}.tilecache.conf
}

################################################################################
# function to get the geotransform
#
# usage:
#       read xo xd xr yo yr yd < <(get_transform "myfile.tif")
################################################################################

function get_transform {
    local infile="$1"
    local xo
    local xd
    local xr
    local yo
    local yr
    local yd

    local tmpdir=$(mktemp -d -p "${tmp}" "${dsname}XXXXXXXXXX")


    gdalbuildvrt -overwrite \
                "${tmpdir}/testy.vrt" \
                "$infile" > /dev/null || return

    read xo xd xr yo yr yd < <(grep GeoTransform "${tmpdir}/testy.vrt" | sed -r 's/<.?GeoTransform>//g' | sed 's/,//g')
    xo=$(fsci2dec "$xo")
    xd=$(fsci2dec "$xd")
    xr=$(fsci2dec "$xr")
    yo=$(fsci2dec "$yo")
    yd=$(fsci2dec "$yd")
    yr=$(fsci2dec "$yr")

    rm -r "$tmpdir"

    echo $xo $xd $xr $yo $yr $yd

}

###############################################################################
# function to get the size of an image
###############################################################################

function get_size {

    gdalinfo $1 | grep -e "Size is"  | sed 's/Size is \([0-9]*\), \([0-9]*\)/\1 \2/'

}

###############################################################################
# function to get the pixel size
###############################################################################

function get_pixelsize {

    gdalinfo "$1" | 
     grep -e "Pixel Size" |\
     sed 's/.*Pixel Size = ([-]*\([.0-9]*\),[-]*\([.0-9]*\)).*/\1 \2/'
}

###############################################################################
# function to get the origin
###############################################################################

function get_origin {

    gdalinfo "$1" | \
     grep -e "Origin" |\
     sed 's/.*Origin = ([-]*\([.0-9]*\),[-]*\([.0-9]*\)).*/\1 \2/'
}



