#!/bin/bash
# Copyright (c) 2011, Brian Case
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.


function myline {

    local line
    
    IFS= read -r line && printf '%s\n' "$line"
    
}

###############################################################################
# function to print an error msg
#
# usage:
#           cmd || printerror [ msg ] ; return
###############################################################################

function printerror {

    ecode=$?
    
    echo "ERROR: ${@:1} ${FUNCNAME[1]} ${BASH_SOURCE[1]}:${BASH_LINENO[0]}" 1>&2

    return $ecode
}


###############################################################################
# function to test for true
###############################################################################

function istrue {
    
   case "$1" in
        [nN][oO])
            false
            ;;
        [yY][eE][sS])
            true
            ;;
        [fF][aA][lL][sS][eE])
            false
            ;;
        [tT][rR][uU][eE])
            true
            ;;
        0)
            false
            ;;
        1)
            true
            ;;
        *)
            ##### if there is a second numeric arg return it by itself,#####
            ##### otherwise return the default of false #####
            
            if [ -n "$2" ]
            then
                return $2
            else
                false
            fi
            ;;
    esac
    
}
###############################################################################
# to remove dupe /'s from a path
###############################################################################

function fixpath {

    sed -r 's|[/]+|/|g' <<<"$1"
}

###############################################################################
# function to get the extent of the ds
###############################################################################

function getextent {
    ts="$1"

    ogrinfo -so -al "${outdir}/${dsname}${ts}.shp" |\
     grep Extent: |\
     sed -e 's/) - (/ /' -e 's/Extent: (//' -e 's/,//g' -e 's/)//'
}

###############################################################################
# min a b
###############################################################################

function fmin {
    
    bc << EOF
scale=20;
define min(a,b) {
    if (a < b) return a;
    return b;
}
min($1, $2)
EOF
}

###############################################################################
# max a b
###############################################################################

function fmax {
    
    bc << EOF
scale=20;
define max(a,b) {
    if (a > b) return a;
    return b;
}
max($1, $2)
EOF
}

###############################################################################
# frontend to bc for calcing floats
###############################################################################

function fcalc {

    if [[ $# -gt 0 ]]
    then
        echo "scale=20; $*" | bc -q 2>/dev/null
    fi
}
    
###############################################################################
# frontend to bc for compareing floats
###############################################################################

function fcmp {

    local cond=0
    if [[ $# -gt 0 ]]
    then
        cond=$(echo "$*" | bc -q 2>/dev/null)
        if [[ -z "$cond" ]]
        then
            cond=0
        fi
        if [[ "$cond" != 0  &&  "$cond" != 1 ]]
        then
            cond=0
        fi
    fi
    local res=$((cond == 0))
    return $res
}

###############################################################################
# convert sci noteation to dec
###############################################################################

function fsci2dec {
    
    fcalc $(sed 's/e[+]*/*10^/g' <<< "$1")
}
    
###############################################################################
# function to get a ts from a lftp command
###############################################################################

RX_YMD='\([0-9]\{4\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)'
RX_MDY='\([0-9]\{2\}\)\([0-9]\{2\}\)\([0-9]\{4\}\)'
RX_YDJ='\([0-9]\{4\}\)\([0-9]\{3\}\)'

Months='january february march april may june july august september
        october november december jan feb mar apr jun jul aug sep sept oct
        nov dec'

RX_LM='\('

needor=0
for m in $Months
do
    if istrue $needor
    then
        RX_LM="$RX_LM"'\|'
    else
        needor=1
    fi

    while read c
    do
        RX_LM="${RX_LM}[$(tr [a-z] [A-Z] <<<"$c")${c}]"
    done < <(fold -w1 <<<"$m")
    
done
RX_LM="$RX_LM"'\)'

RX_MLD="$RX_LM"'\([0-9]\{2\}\)'


RX_USGSID='[A-Z]\{2\}[0-9]\{2\}'
RX_PATHROW='[0-9]\{3\}[0-9]\{3\}'
RX_LAT='[NS][0-9]\{2\}_[0-9]\{6\}'
RX_LON='[EW][0-9]\{3\}_[0-9]\{6\}'

function dodate {
    sed -e "s:.*/${RX_USGSID}${RX_PATHROW}${RX_YMD}.*:jan 1 \1 - 1 month - 1 days + \2 months \3 days:g" \
        -e "s:.*/${RX_USGSID}${RX_LAT}${RX_LON}${RX_YMD}.*:jan 1 \1 - 1 month - 1 days + \2 months \3 days:g" \
        -e "s:.*/AST_L1[AB]E_[0-9]\{3\}_${RX_MDY}${RX_PATHROW}_${RX_MDY}.*:jan 1 \6 - 1 month - 1 days + \4 months \5 days:g" \
        -e "s:.*/AST_L1B_[0-9]\{3\}${RX_MDY}.*:jan 1 \3 - 1 month - 1 days + \1 months \2 days:g" \
        -e "s:.*/.*[.][A-Z]${RX_YDJ}[.].*:jan 1 \1 \2 days - 1 day:g" \
        -e "s:.*/${RX_MLD}.*:\1 \2:g" \
        -e "s:.*/.*[.]${RX_YDJ}[.]\(aqua\|terra\).*:jan 1 \1 \2 days - 1 day:g" \
        -e "s:.*/EO1[AH]${RX_PATHROW}${RX_YDJ}.*:jan 1 \1 \2 days - 1 day:g" \
        -e "s:.*/LT[0-9]${RX_PATHROW}${RX_YDJ}.*:jan 1 \1 \2 days - 1 day:g" \
     | date -f /dev/stdin "+%Y%m%d" | sed 's:^get.*::g'
     
}

###############################################################################
# function to get the a list of new files
###############################################################################

function getlist {
    local mirrorfile="$1"
    local pattern="$2"
    
    ##### get the list of files on the site #####
    
    mirrorscript="$(lftp "$baseurl" -e "mirror --just-print ; exit")"
    
    ##### if pattern is set get a list of those files #####

    local regex="${pattern//./[.]}"
    local regex="${regex//\*/.*}"
    local regex="${regex//\?/.}"
    
    if [ -n "$pattern" ] 
    then
        if grep -i -e "$regex" <<<"$mirrorscript" > /dev/null
        then
            local files="$(grep -i -e "$regex" <<<"$mirrorscript")"
        else
            return
        fi
    
    ##### tif #####
    
    elif grep -i -e "[.]tif$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]tif$" <<<"$mirrorscript")"

    ##### zip #####
    
    elif grep -i -e "[.]zip$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]zip$" <<<"$mirrorscript")"
        local isarchive="yes"
        
    ##### tar.gz #####
    
    elif grep -i -e "[.]tar.gz$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]tar.gz$" <<<"$mirrorscript")"
        local isarchive="yes"
        
        
    ##### tgz #####
    
    elif grep -i -e "[.]tgz$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]tgz$" <<<"$mirrorscript")"
        local isarchive="yes"
        
    ##### tar.bz2 #####
    
    elif grep -i -e "[.]tar.bz2$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]tar.bz2$" <<<"$mirrorscript")"
        local isarchive="yes"
        
    ##### tar #####
    
    elif grep -i -e "[.]tar$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]tar$" <<<"$mirrorscript")"
        local isarchive="yes"
        
    ##### jpeg2000 #####
    
    elif grep -i -e "[.]jp2$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]jp2$" <<<"$mirrorscript")"
    
    ##### png #####
    
    elif grep -i -e "[.]png$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]png$" <<<"$mirrorscript")"
    
    ##### jpg #####
    
    elif grep -i -e "[.]jpg$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]jpg$" <<<"$mirrorscript")"
    
    ##### gif #####
    
    elif grep -i -e "[.]gif$" <<<"$mirrorscript" > /dev/null
    then
        local files="$(grep -i -e "[.]gif$" <<<"$mirrorscript")"
    
    ##### no match, bail #####
    
    else
        return
    fi
    
    ##### add the mkdir commands to the mirrorfile first #####
    
    grep -e "^mkdir" <<<"$mirrorscript" > "$mirrorfile"
    
    ##### loop over the list of files to fetch #####
    
    local line
    while read line 
    do
    
        local file="${line##*/}"

        local base="${file%.*}"
        local base2="${base%.*}"
        local ext="${file##*.}"
        if [[ "$isarchive" = "yes" ]]
        then
            echo "$line"
        else
            
            ##### test for world and aux files #####

            local world="$(grep -i -e "${sdir}${base}[.]..w$" <<<"$mirrorscript" | head -n 1)"
            local aux="$(grep -i -e "${sdir}${base}[.]aux$" <<<"$mirrorscript" | head -n 1)"
            local auxxml="$(grep -i -e "${sdir}${base}[.]aux.xml$" <<<"$mirrorscript" | head -n 1)"
        
            if [ -n "$world" ]
            then
                echo -n "$world ; "
            fi
            
            if [ -n "$aux" ]
            then
                echo -n "$aux ; "
            fi
            
            if [ -n "$auxxml" ]
            then
                echo -n "$auxxml ; "
            fi
            
            echo "$line"
        fi >> "$mirrorfile"
        
    done <<<"$files"
            
    
}





function dotc_old {

(
    for map in $(find $outdir -name "*.map" | sort )
    do
        if istrue "$doovr" 1
        then
            layer=$(grep "$map" -e GROUP | cut -d "'" -f 2 | uniq )
        else
            layer=$(grep "$map" -e NAME  | cut -d "'" -f 2 | uniq )
        fi
        
        cat << EOF

[${layer}]
type=WMS
url=${urlcgibin}?
layers=${layer}
extension=png
tms_type=google
levels=24
spherical_mercator=true

EOF

    done
) > ${basedir}/${dsname}.tilecache.conf
}

################################################################################
# function to get the geotransform
#
# usage:
#       read xo xd xr yo yr yd < <(get_transform "myfile.tif")
################################################################################

function get_transform {
    local infile="$1"
    local xo
    local xd
    local xr
    local yo
    local yr
    local yd

    local tmpdir=$(mktemp -d -p "${tmp}" "${dsname}XXXXXXXXXX")


    gdalbuildvrt -overwrite \
                "${tmpdir}/testy.vrt" \
                "$infile" > /dev/null || return

    read xo xd xr yo yr yd < <(grep GeoTransform "${tmpdir}/testy.vrt" | sed -r 's/<.?GeoTransform>//g' | sed 's/,//g')
    xo=$(fsci2dec "$xo")
    xd=$(fsci2dec "$xd")
    xr=$(fsci2dec "$xr")
    yo=$(fsci2dec "$yo")
    yd=$(fsci2dec "$yd")
    yr=$(fsci2dec "$yr")

    rm -r "$tmpdir"

    echo $xo $xd $xr $yo $yr $yd

}

###############################################################################
# function to get the size of an image
###############################################################################

function get_size {

    gdalinfo $1 | grep -e "Size is"  | sed 's/Size is \([0-9]*\), \([0-9]*\)/\1 \2/'

}

###############################################################################
# function to get the pixel size
###############################################################################

function get_pixelsize {

    gdalinfo "$1" | 
     grep -e "Pixel Size" |\
     sed 's/.*Pixel Size = (\([-.0-9]*\),\([-.0-9]*\)).*/\1 \2/'
}

###############################################################################
# function to get the origin
###############################################################################

function get_origin {

    gdalinfo "$1" | \
     grep -e "Origin" |\
     sed 's/.*Origin = (*\([-.0-9]*\),*\([-.0-9]*\)).*/\1 \2/'
}

###############################################################################
# function to get the number of bands
###############################################################################

function get_num_bands {
    gdalinfo "$1" | grep "^Band " | wc -l
}

###############################################################################
# function to get a bands type
###############################################################################

function get_band_type {
    gdalinfo "$1" | grep "^Band $2 " | grep "Type=" | sed 's/.*Type=\(\w*\).*/\1/' | head -n 1
}

###############################################################################
# function to get a bands type
###############################################################################

function get_srs {
    echo $(gdalinfo "$1" | sed -n '/PROJCS\|GEOGCS/,${//p;/^   /p;}' | uniq | tr "\n" " " |  sed -e 's/[ ]*//g' -e 's/"/&quot;/')  
}

###############################################################################
# an array of gdal types
###############################################################################

GDAL_TYPES=( Byte UInt16 Int16 UInt32 Int32 
             Float32 Float64)

###############################################################################
# function encode a url
###############################################################################

function url_encode_awk {
    LANG=C awk '
$1 == "20"                    { printf("%s",   "+"); next } # space becomes plus
$1 ~  /0[adAD]/               {                      next } # strip newlines
$2 ~  /^[a-zA-Z0-9.*()\/-]$/  { printf("%s",   $2);  next } # pass through what we can
                              { printf("%%%s", $1)        } # take hex value of everything else
'
}

function url_encode {
    if ! [ -n "$1" ]
    then
        return 1
    fi

    local encodedurl="$1";
    
    hexdump -v -e '1/1 "%02x\t"' -e '1/1 "%_c\n"' <<<"$encodedurl" |\
     url_encode_awk
    
    ##### needs A NEWLINE #####
    
    echo

}

###############################################################################
# function to get the query part of a url
###############################################################################

function url_get_query {
    if ! [ -n "$1" ]
    then
        return 1
    fi
    
    local url=$1
    url="${url#*\?}"
    url="/${url%%\#*}"
    
    echo "$url"
    
}
    
###############################################################################
# function to get the hash part of a url
###############################################################################

function url_get_hash {
    if ! [ -n "$1" ]
    then
        return 1
    fi
    
    local url=$1
    url="${url#*\#}"
    
    echo "$url"
    
}

###############################################################################
# function to get the path part of a url
###############################################################################

function url_get_path {
    if ! [ -n "$1" ]
    then
        return 1
    fi
    
    local url=$1
    
    url="${url/*:??/}"
    url="/${url#*/}"
    url="/${url%%\#*}"
    url="/${url%%\?*}"
    
    echo "$url"
    
}

###############################################################################
# function to get the host part of a url
###############################################################################

function url_get_host {
    if ! [ -n "$1" ]
    then
        return 1
    fi
    
    local url=$1
    
    url="${url/*:??/}"
    url="${url#*@}"
    url="${url%%/*}"
    
    echo "$url"
    
}

###############################################################################
# function to get the host part of a url
###############################################################################

function url_get_proto {
    if ! [ -n "$1" ]
    then
        return 1
    fi
    
    local url=$1
    
    url="${url%%://*}"

    echo "$url"
    
}

###############################################################################
# function to test if a value is un an array
###############################################################################

function isinarray {
    local val = $1
    local result=1
    shift
    
    local elem
    for elem;
    do
        if [[ "$val" = "$elem" ]]
        then
            result=0
            break;
        fi
    done
    
    return $result
}



