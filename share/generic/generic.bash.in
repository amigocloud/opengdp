#!/bin/bash
# Copyright (c) 2011, Brian Case
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.




source @GENERICDIR@/misc.bash
source @GENERICDIR@/addo.bash
source @GENERICDIR@/index.bash
source @GENERICDIR@/image.bash
source @GENERICDIR@/vector.bash
source @GENERICDIR@/file.bash
source @GENERICDIR@/mapfile.bash
source @GENERICDIR@/ms_overview.bash
source @GENERICDIR@/geoext.bash
source @GENERICDIR@/tc.bash
source @GENERICDIR@/pan.bash


###############################################################################
# est completion time meter
###############################################################################

function comp_meter {

    started=$1
    lines=$2
    donelines=$3
    
    decdone=$(fcalc "$donelines / $lines")
    percdone=$(fcalc "scale = 0; $decdone * 100")
    elap=$(($(date +%s) - started))
    comp=$(fcalc "scale=0; $elap / $decdone")
    ((comp +=  started))
    
    printf "\r%3.0f%% complete. EST. finish at %s" $percdone "$(date -d "@${comp}")"
}

###############################################################################
# multi proceessing loop
###############################################################################

function mainloop {
    local mirrorfile="$1"
    
    ((doing=0))
    
    ##### open a fd to a named pipe #####

    mkfifo pipe; exec 3<>pipe
    
    ##### setup for the est completion time #####
    
    lines=$(grep "${mirrorfile}" -e "^get" | wc -l  | cut -d " " -f 1 )
    ((donelines=0))
    started=$(date +%s)
    
    ##### loop over the list #####

    while read line ;
    do
        
        ##### if it is a mkdir command do it now #####
        
        if grep -e "^mkdir" <<< "$line" > /dev/null
        then
            lftp -e "$line ; exit"
            continue
        fi
        
        ##### under the limit just start a job #####

        if [ $doing -lt $limit ]
        then
        	dofile "$line"  &
         	((doing++))
         	
        ##### over the limit wait for a job to finish before starting #####
        
        else
            read <&3
            ((doing--))
            
            if grep -e "^get" <<< "$line" > /dev/null
            then
                ((donelines++))
            fi

            comp_meter $started $lines $donelines
            
            dofile "$line"  &
         	((doing++))
        fi

    done < "${mirrorfile}"

    wait

    echo

}

###############################################################################
# usage
###############################################################################

function usage {

echo "$1 [ -h ] || [ -v ] || | [ -rebuild ] || [ -readdo ] || [ -retindex ] ||"
echo "                            [ -reover ] || [ -remapfile || [ -regeoext ]"
}

###############################################################################
# sub main function
###############################################################################

opt_none=0
opt_rebuild=1
opt_readdo=2
opt_retindex=3
opt_reindex=4
opt_reover=5
opt_remapfile=6
opt_regeoext=7
opt_none=0

function sub_main {
    local ts
    
    ((stage = opt_none))
    ((stop = 0))

    while [[ $1 == -* ]]; do
        case "$1" in
            -h|--help|-\?)
                usage $0
                exit 0
                ;;
            -v|--verbose)
                ((verbose=1))
                shift
                ;;
            -rebuild|--rebuild)
                ((stage=opt_rebuild))
                shift
                ;;
            
            -readdo|--readdo)
                ((stage=opt_readdo))
                shift
                ;;
            -retindex|--retindex)
                ((stage=opt_retindex))
                shift
                ;;
            -reindex|--reindex)
                ((stage=opt_reindex))
                shift
                ;;
            -reover|--reover)
                ((stage=opt_reover))
                shift
                ;;
            -remapfile|--remapfile)
                ((stage=opt_remapfile))
                shift
                ;;
            -regeoext|--regeoext)
                ((stage=opt_regeoext))
                shift
                ;;
            -stop|--stop)
                ((stop=1))
                shift
                ;;
            -findtile|--findtile)
                findtile="$2 $3"
                shift
                shift
                shift
                ;;
            -*)
                echo "invalid option: $1" 1>&2
                usage $0
                exit 1
                ;;
        esac
    done

    if ((stage == opt_none)) && ((stop == 1))
    then
        echo "Ignoreing -stop switch, no rebuild stage specified"
        ((stop = 0))
    fi

    ##### findtile #####
    
    if [ -n "$findtile" ]
    then
        
        ogrinfo "$outdir" -al -spat $findtile $findtile | grep "  location (String) = "
        exit
    fi
    

    ##### check if called for a rebuild #####
    
    if (( stage == opt_rebuild ))
    then
        echo "rebuilding"
        DWH_REBUILD="rebuild"
        if ! mv "$indir" "${indir/%\//}.old"
        then
            exit
        fi

        ##### loop over the subdataset array #####
        
        if [[ ${#subdsnames[@]} == 0 ]]
        then
            local subdsnames=( "" )
        fi
        local sub
        for sub in "${subdsnames[@]}"
        do
            (
                outdir="${outdir}${sub}"
                dsname="${dsname}${sub}"
            
                if ! mv "$outdir" "${outdir/%\//}.old"
                then
                    exit
                fi
            )
        done
        
        if ! mkdir -p "$indir"
        then
            exit
        fi
        
        cd "$indir"

        baseurl="file://${indir/%\//}.old"

    fi
    
    ##### normal op or -rebuild #####
    
    if (( stage <= opt_rebuild ))
    then
    
        ##### get the list of new files to fetch #####
        
        if ! getlist "$mirrorfile" "$fetchpattern"
        then
            exit
        fi
        
        ##### loop over the commands in the mirrorfile #####
        
        if ! mainloop "$mirrorfile"
        then
            exit
        fi

        if istrue $stop
        then
            
            ##### clean up after a -rebuild #####
            
            if (( stage == $opt_rebuild ))
            then
                echo "rebuilding"
                rm -r "$indir"

                mv "${indir/%\//}.old" "$indir"

            fi
            exit
        fi
    fi

    ##### -readdo only #####
    
    if (( stage == opt_readdo ))
    then
    
                ##### loop over the subdatasets if any #####
            
        if [[ ${#subdsnames[@]} == 0 ]]
        then
            local subdsnames=( "" )
        fi
        local sub
        for sub in "${subdsnames[@]}"
        do
            (
                outdir="${outdir}${sub}"
                dsname="${dsname}${sub}"
                
               readdo
            )
        done

        istrue $stop && exit
    fi
    
    ##### -retindex only #####
    
    if (( stage == opt_retindex ))
    then
        ##### loop over the subdatasets if any #####
            
        if [[ ${#subdsnames[@]} == 0 ]]
        then
            local subdsnames=( "" )
        fi
        local sub
        for sub in "${subdsnames[@]}"
        do
            (
                outdir="${outdir}${sub}"
                dsname="${dsname}${sub}"
                
                rebuildtindexs
            )
        done
            
        istrue $stop && exit
    fi
    
    ##### -reindex only #####
    
    if (( stage == opt_reindex )) || (( stage == opt_rebuild ))
    then
        
        ##### loop over the subdatasets if any #####
            
        if [[ ${#subdsnames[@]} == 0 ]]
        then
            local subdsnames=( "" )
        fi
        local sub
        for sub in "${subdsnames[@]}"
        do
            (
                outdir="${outdir}${sub}"
                dsname="${dsname}${sub}"
                
                index_drop_ds
                
                while read ts
                do
                    index_add_layer "$ts" "$(getextent "$ts")"
                
                done < <( find "${outdir}" -mindepth 1 -maxdepth 1 -type d -name "[0-9]*" |\
                           sed 's:.*/::g')
                
            )
        done
        
        istrue $stop && exit
    fi
    
    ##### -reover or before #####
            
    if (( stage <= opt_reover))
    then
        
        ##### loop over the subdatasets if any #####
            
        if [[ ${#subdsnames[@]} == 0 ]]
        then
            local subdsnames=( "" )
        fi
        local sub
        for sub in "${subdsnames[@]}"
        do
            (
                outdir="${outdir}${sub}"
                dsname="${dsname}${sub}"
                
                ##### if stage is 0 only do the layers we built #####
                
                if (( stage == 0 ))
                then
                    grep "${mirrorfile}" -e "^get" |\
                     dodate |\
                     grep -v -e "^get" |\
                     sort |\
                     uniq
                
                ##### redo all the layers #####
                
                else
                    index_get_layers | cut -d "|" -f 3
                fi |\
                 while read ts
                do
                
                    ##### get the extent of the ds #####

                    extent=$(getextent "$ts")
                
                    ##### if stage is 0 add to the index #####
                
                    if (( stage == 0 ))
                    then
                        index_add_layer "$ts" "$extent" 
                    fi

                    addinclude "$ts"

                    ##### add an include line in the main Newworld mapfile #####

                    addinclude_NewWorld "$ts"

                    if istrue "$doovr" 1
                    then

                        ##### write a temp map file #####

                        writemap_noover "$ts" "$extent"

                        ##### create a single file for larger area overviews #####

                        scale=$(makeoverview "$ts" "$extent")

                        ##### write the map file with the correct scale #####

                        writemap_withover "$ts" "$extent" "$scale"

                    else

                        ##### write the map file with no min max layers #####

                        writemap_noover "$ts" "$extent"

                    fi

                    ##### create a map file for new world #####
                    
                    writemap_NewWorld "$ts" "$extent"

                done
            )
        done
        
        istrue $stop && exit
    fi
    
    ##### -remapfile only #####
    
    if (( stage == opt_remapfile ))
    then
    
        ##### loop over the subdatasets if any #####

        if [[ ${#subdsnames[@]} == 0 ]]
        then
            local subdsnames=( "" )
        fi
        local sub
        for sub in "${subdsnames[@]}"
        do
            (
                outdir="${outdir}${sub}"
                dsname="${dsname}${sub}"

                index_get_layers | cut -d "|" -f 3 | 
                 while read ts
                do  

                    ##### add an include line in the main mapfile #####

                    addinclude "$ts"

                    ##### add an include line in the main Newworld mapfile #####

                    if [ -n "$NewWorld_mapfile" ]
                    then
                        addinclude_NewWorld "$ts"
                    fi

                    ##### get the extent of the ds #####

                    extent=$(getextent "$ts")

                    if istrue "$doovr" 1
                    then

                        ##### get the overview scale from the old mapfile #####

                        scale=$(getoverviewscale "$ts")
 
                        ##### write the map file with the correct scale #####

                        writemap_withover "$ts" "$extent" "$scale"

                    else

                        ##### write the map file with no min max layers #####

                        writemap_noover "$ts" "$extent"

                    fi

                    ##### create a map file for new world #####

                    if [ -n "$NewWorld_mapfile" ]
                    then
                        writemap_NewWorld "$ts" "$extent"
                    fi

                done
            )
        done

        istrue $stop && exit
    fi
    
    ##### stage regeoext and before #####
    #####  write out a js file for geoext #####
    
    if (( stage <= opt_regeoext))
    then        
        
        ##### loop over the subdatasets if any #####
        
        if [[ ${#subdsnames[@]} == 0 ]]
        then
            local subdsnames=( "" )
        fi
        
        local sub
        for sub in "${subdsnames[@]}"
        do
            (
                outdir="${outdir}${sub}"
                dsname="${dsname}${sub}"

                dogeoext
                
                dogeoext_tc

                ##### write out a config section for tilecache #####

                dotc
                
            )
        done
        
        istrue $stop && exit
    fi
    
    ##### clean up after a -rebuild #####

    if (( stage == opt_rebuild ))
    then
        echo "rebuilding"
        rm -r "$indir"
        mv "${indir/%\//}.old" "$indir"
            
    fi

}

###############################################################################
# main
###############################################################################

function main {
    
    ##### project #####

    if ! [[ -n "${project}" ]]
    then
        echo "ERROR: var project not set"
        exit
    fi
    

    ##### dsname #####
    
    if ! [[ -n "${dsname}" ]]
    then
        echo "ERROR: var dsname not set"
        exit
    fi
    
    ##### fetch url #####
    
    if ! [[ -n "${baseurl}" ]]
    then
        echo "ERROR: var baseurl not set"
        exit
    fi
    
    ##### basedir #####
    
    if ! [[ -n "${basedir}" ]]
    then
        echo "ERROR: var basedir not set"
        exit
    fi
    
    if ! [ -d "$basedir" ]
    then
        echo "ERROR: no such dir $basedir"
        exit
    fi
    
    if ! [ -w "$basedir" ]
    then
        echo "ERROR: no write access to $basedir"
        exit
    fi
    
    ##### indir #####
    
    if ! [[ -n "${indir}" ]]
    then
        echo "ERROR: var indir not set"
        exit
    fi
    
    
    if ! [ -d "$indir" ]
    then
        if ! mkdir -p "$indir"
        then
            exit
        fi
    fi
    
    if ! [ -w "$indir" ]
    then
        echo "ERROR: no write access to $indir"
        exit
    fi
    
    ##### outdir #####
    
    if ! [[ -n "${outdir}" ]]
    then
        echo "ERROR: var outdir not set"
        exit
    fi
    
    ##### loop over the subdataset array #####
    
    if [[ ${#subdsnames[@]} == 0 ]]
    then
        local subdsnames=( "" )
    fi
    local sub
    for sub in "${subdsnames[@]}"
    do
        (
            outdir="${outdir}${sub}"
            dsname="${dsname}${sub}"
            if ! [ -d "$outdir" ]
            then
                if ! mkdir -p "$outdir"
                then
                    exit
                fi
            fi
            
            if ! [ -w "$outdir" ]
            then
                echo "ERROR: no write access to $outdir"
                exit
            fi
        ) || exit
    done
    
    ##### tmp dir #####
    
    if ! [ -n "$tmp" ] ; then tmp="/tmp/" ; fi
    
    if ! [ -d "$tmp" ]
    then
        echo "ERROR: no such dir $tmp"
        exit
    fi
    
    if ! [ -w "$tmp" ]
    then
        echo "ERROR: no write access to $tmp"
        exit
    fi
    
    ##### mapfile #####
    
    if ! [[ -n "${mapfile}" ]]
    then
        echo "ERROR: var mapfile not set"
        exit
    fi
    
    if ! [ -f "$mapfile" ]
    then
        write_main_map
    fi

    if ! [ -f "$mapfile" ]
    then
        echo "ERROR: no such file $mapfile"
        exit
    fi

    if ! [ -w "$mapfile" ]
    then
        echo "ERROR: no write access to $mapfile"
        exit
    fi
    
    ##### mapserverpath #####
    
    if ! [ -n "$mapserverpath" ] ; then mapserverpath="/usr/local/src/mapserver/mapserver/" ; fi
    
    if ! [ -d "$mapserverpath" ]
    then
        echo "ERROR: no such dir $mapserverpath"
        exit
    fi
    
    ##### resamp_alg #####
    
    if ! [ -n "$resample_alg" ] ; then resample_alg="average" ; fi

    ##### unzip kmz pattern default #####
    
    if ! [ -n "$baseglob" ] ; then baseglob="tile-*" ; fi
    
    ##### proccess limit default #####
    
    if ! [ -n "$limit" ]
    then
        if [ -f /proc/cpuinfo ]
        then
            limit=$(grep /proc/cpuinfo -e "^processor" | wc -l)
        else
            limit="4"
        fi
    fi
    
    if ! [ -n "$datefunc" ] ; then datefunc="dodate" ; fi

    ##### cd to the in dir #####

    cd "$indir"

    ##### file name for the mirror file #####
    
    host="$(hostname)"
    mirrorfile="$host.mirror.lftp"
    
    sub_main "$@"

}


