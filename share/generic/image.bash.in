#!/bin/bash
# Copyright (c) 2011, Brian Case
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

###############################################################################
# function to proccess a single file
###############################################################################

function dosubimg {
    local img="$1"
    local tmpdir="$2"
    local ts="$3"
    local info="$4"
    local islossy="$5"
    local isoriginal="$6"

    local imgfile="${img##*/}"
    local imgbase="${imgfile%.*}"
    local imgext="${imgfile##*.}"
    local imgextlower="$(tr [A-Z] [a-z] <<< "$imgext")"
    
    local imgdir="${img%/*}"
    if [[ "$imgdir" = "$imgfile" ]]
    then
        local imgdir=""
    else
        local imgdir="${imgdir}/"
    fi
    
    ##### if we need a debug do it and return #####

    if [ -n "$DEBUG_dosubimg" ]
    then            
        printf " img=%s\n tmpdir=%s\n ts=%s\n imgfile=%s\n imgbase=%s\n imgext=%s\n imgdir=%s\n islossy=%s\n isoriginal=%s\n " \
              "$img" \
              "$tmpdir "\
              "$ts" \
              "$imgfile" \
              "$imgbase" \
              "$imgext" \
              "$imgdir" \
              "$islossy" \
              "$isoriginal"
        return
    fi

    ###### RAMDISK? #####

    if [ -n "$ramdisk" ]
    then
        local tmpram=$(mktemp -d -p "${ramdisk}" "${dsname}XXXXXXXXXX")
    else
        local tmpram=$(mktemp -d -p "${tmpdir}" "${dsname}XXXXXXXXXX")
    fi

    ##### test the projection ####
       
    if ! echo $info | grep 'GEOGCS."WGS 84", DATUM."WGS_1984", SPHEROID."WGS 84",6378137,298.257223563,.* PRIMEM.*"Greenwich",0.*UNIT[[]*"degree".*AUTHORITY."EPSG","4326"\]\][^,]' > /dev/null
                      #GEOGCS."WGS 84", DATUM."WGS_1984", SPHEROID."WGS 84",6378137,298.257223563, AUTHORITY."EPSG","7030".., AUTHORITY."EPSG","6326".., PRIMEM.."Greenwich",0.*., UNIT."degree",0.0174532925199433., AUTHORITY."EPSG","4326"..' > /dev/null
    then

        ##### does the image not have an alpha band? #####
        
        if ! echo "$info" | grep 'ColorInterp=Alpha' > /dev/null
        then
            
            #####  create a mask with the nearblack method #####
            
            if [[ "$islossy" == "true" ]]
            then
                if [[ "$nearwhite" == "true" ]]
                then
                    nearblack -co TILED=YES -setmask -nb 0 -white -of GTiff "${tmpdir}/${img}" \
                              -o "${tmpram}/prewarp_${imgbase}.tif" > /dev/null || return
                else
                    nearblack -co TILED=YES -setmask -nb 0 -of GTiff "${tmpdir}/${img}" \
                             -o "${tmpram}/prewarp_${imgbase}.tif" > /dev/null || return
                fi
            else
                if [[ "$nearwhite" == "true" ]]
                then
                    nearblack -co TILED=YES -setmask -near 0 -nb 0 -white -of GTiff "${tmpdir}/${img}" \
                             -o "${tmpram}/prewarp_${imgbase}.tif" > /dev/null || return
                else
                    nearblack -co TILED=YES -setmask -near 0 -nb 0 -of GTiff "${tmpdir}/${img}" \
                             -o "${tmpram}/prewarp_${imgbase}.tif" > /dev/null || return
                fi
            fi
            
            if [[ "$isoriginal" == "no" ]]
            then
                rm "${tmpdir}/${img}"
            fi

            ##### needs warped #####
        
            gdalwarp -co TILED=YES \
                     -dstalpha \
                     -t_srs EPSG:4326 \
                     "${tmpram}/prewarp_${imgbase}.tif" \
                     "${tmpram}/warped_${imgbase}.tif" > /dev/null || return
            
            #####  create a mask and compress #####
            
            rm "${tmpram}/prewarp_${imgbase}.tif"

            gdal_translate -co TILED=YES -co JPEG_QUALITY=80 -co COMPRESS=JPEG -co PHOTOMETRIC=YCBCR \
                     -b 1 -b 2 -b 3 -mask 4 \
                     "${tmpram}/warped_${imgbase}.tif" \
                     "${tmpram}/final_${imgbase}.tif" > /dev/null || return
            rm "${tmpram}/warped_${imgbase}.tif"

        ##### since it has a alpha band already skip the nearblack #####
        
        else
        
            ##### needs warped #####
        
            gdalwarp -co TILED=YES \
                     -t_srs EPSG:4326 \
                     "${tmpdir}/${img}" \
                     "${tmpram}/warped_${imgbase}.tif"  > /dev/null || return
            
            if [[ "$isoriginal" == "no" ]]
            then
                rm "${tmpdir}/${img}"
            fi

            #####  create a mask and compress #####
            
            gdal_translate -co TILED=YES -co JPEG_QUALITY=80 -co COMPRESS=JPEG -co PHOTOMETRIC=YCBCR \
                     -b 1 -b 2 -b 3 -mask 4 \
                     "${tmpram}/warped_${imgbase}.tif" \
                     "${tmpram}/final_${imgbase}.tif"  > /dev/null || return

            rm "${tmpram}/warped_${imgbase}.tif"
            
        fi
            
    ##### already the right proj #####
      
    else
        
        ##### if the source is anything but a tif or does #####
        ##### not have a alpha band we need to copy       #####
        
        if echo "$info" | grep 'ColorInterp=Alpha' > /dev/null
        then

            gdal_translate -co TILED=YES -co JPEG_QUALITY=80 -co COMPRESS=JPEG -co PHOTOMETRIC=YCBCR \
                     -b 1 -b 2 -b 3 -mask 4 \
                     "${tmpdir}/${img}" \
                     "${tmpram}/final_${imgbase}.tif" > /dev/null || return
            
            if [[ "$isoriginal" == "no" ]]
            then
                rm "${tmpdir}/${img}"
            fi

        else
            
            #####  create a mask and compress #####

            if [[ "$islossy" == "true" ]]
            then
                if [[ "$nearwhite" == "true" ]]
                then
                    nearblack -co TILED=YES -nb 0 -setmask -white -of GTiff \
                             "${tmpdir}/${img}" \
                             -o "${tmpram}/final_${imgbase}.tif" > /dev/null || return
                else
                    nearblack -co TILED=YES -nb 0 -setmask -of GTiff \
                             "${tmpdir}/${img}" \
                             -o "${tmpram}/final_${imgbase}.tif" > /dev/null || return
                fi
            else
                if [[ "$nearwhite" == "true" ]]
                then
                    nearblack -co TILED=YES -setmask -white -of GTiff \
                             -near 0 -nb 0 \
                             "${tmpdir}/${img}" \
                             -o "${tmpram}/final_${imgbase}.tif" > /dev/null || return
                else
                    nearblack -co TILED=YES -setmask -of GTiff \
                             -near 0 -nb 0 \
                             "${tmpdir}/${img}" \
                             -o "${tmpram}/final_${imgbase}.tif" > /dev/null || return
                fi
            fi

            if [[ "$isoriginal" == "no" ]]
            then
                rm "${tmpdir}/${img}"
            fi
        fi
    fi
        
    ##### add overviews #####
    
    addo "${tmpram}/final_${imgbase}.tif"
    
    ##### add a timestamp for indexers #####
    
    tiffset -s 306 \
                "${ts:0:4}:${ts:4:2}:${ts:6:2} 12:00:00" \
                "${tmpdir}/final_${imgbase}.tif" > /dev/null 2> /dev/null
        
    ##### move the output to the outdir #####
    
    mv "${tmpram}/final_${imgbase}.tif" "$outdir/${ts}/${imgbase}.tif" || return
    
    rm -rf "${tmpram}"
    ##### add the file to the tile index #####
    
    ##### lock! #####
    
    local lock="${outdir}/${dsname}${ts}.shp"
    lock="${lock//\//.}"
    
    while ! mkdir "${lock}" 2> /dev/null
	do
		sleep 1
	done
    
    ##### make the tileindex in a subshell so we can cd with no adverse effect #####
    ##### this costs like 2s of system time per 4000 calls #####

    if [ -n "$isoverview" ]
    then
        (
            cd ${outdir}
            gdaltindex "overview_${dsname}${ts}.shp" "${ts}/${imgbase}.tif"  > /dev/null
        )
    else
 
        (
            cd ${outdir}
            gdaltindex "${dsname}${ts}.shp" "${ts}/${imgbase}.tif"  > /dev/null
        )
    
    fi

    ##### unlock #####
    
    rmdir "${lock}"
    
    if [[ "$haveomar" == "yes" ]]
    then
        curl --data "filename=${outdir}/${ts}/${imgbase}.tif" \
             "${urlbase}/omar/dataManager/addRaster"
    fi
    
}

function myrescale {
    ##### check if the image needs scaled #####
    
    if ! echo "$info" | grep -e Band.1.*Type=Byte > /dev/null && ! [ -n "$rescale" ]
    then
        
        type="$(echo "$info" | grep -e "Band 1 " | sed 's|.*Type=\([a-zA-Z0-9]*\),.*|\1|')"
        case "$type" in

            UInt16)
                local rescale="-32768 32767"
            ;;
            Int16)
                local rescale="0 65535"
            ;;
            UInt32)
                local rescale="-2147483,648 2147483647"
            ;;
            Int32)
                local rescale="0 4294967295"
            ;;

            ##### all other types we just let gdal scale with minmax #####

        esac
        
        local doscale=TRUE
    fi

    if [[ "$doscale" == "TRUE" ]] || [ -n "$rescale" ]
    then

        gdal_translate -of VRT -ot byte -scale $rescale \
                       "${tmpdir}/${img}"\
                       "${tmpdir}/${imgdir}${imgbase}_scaled.vrt" > /dev/null


        img="${imgdir}${imgbase}_scaled.vrt"
        imgfile="${img##*/}"
        imgbase="${imgfile%.*}"
        imgext="${imgfile##*.}"
        
    fi
}

###############################################################################
# function to bust a larger image into chunks and proccess
###############################################################################

function doimg {
    local img="$1"
    local tmpdir="$2"
    local ts="$3"
    local info="$4"
    local isoriginal="$5"
    
    
    local imgfile="${img##*/}"
    local imgbase="${imgfile%.*}"
    local imgext="${imgfile##*.}"
    local imgextlower="$(tr [A-Z] [a-z] <<< "$imgext")"
    local imgdir="${img%/*}"
    
    local imgdir="${img%/*}"
    if [[ "$imgdir" = "$imgfile" ]]
    then
        local imgdir=""
    else
        local imgdir="${imgdir}/"
    fi
    
    ##### double check the info #####
    
    if [ -n "$info" ]
    then
        info="$(gdalinfo "${tmpdir}/${img}")"
    fi
   
    ##### if we need a debug do it and return #####

    if [ -n "$DEBUG_doimg" ]
    then
        printf " img=%s\n tmpdir=%s\n ts=%s\n imgfile=%s\n imgbase=%s\n imgext=%s\n imgdir=%s \n" \
               "$img" \
               "$tmpdir "\
               "$ts" \
               "$imgfile" \
               "$imgbase" \
               "$imgext" \
               "$imgdir"
       return
    fi

    ##### test if the image is in a lossy format #####
     
    if grep -e "COMPRESSION=.*JP" <<< "$info" > /dev/null || \
       [[ "$imgextlower" == "sid" ]] || [[ "$imgextlower" == "pdf" ]]
    then
        local islossy=true
    fi
    
    ##### do we need to add a srs to the image #####
    
    if  [ -n "$s_srs" ] && ! [ -n "$isoverview" ]
    then
        ##### create a vrt with the proj #####
        
        gdal_translate -a_srs "$s_srs" \
                       -of VRT -mask none \
                       "${tmpdir}/${img}" \
                       "${tmpdir}/${imgdir}${imgbase}_srs.vrt" > /dev/null || return

        img="${imgdir}${imgbase}_srs.vrt"
        imgfile="${img##*/}"
        imgbase="${imgfile%.*}"
        imgext="${imgfile##*.}"
        info="$(gdalinfo "${tmpdir}/${imgdir}${imgbase}.vrt")"
    fi

    ##### is the image bnw? #####
    
    if [[ "$bnw" == "yes" ]]
    then
        gdalbuildvrt -separate "${tmpdir}/${imgdir}${imgbase}_bnw.vrt" "${tmpdir}/${img}" "${tmpdir}/${img}" "${tmpdir}/${img}"
        
        img="${imgdir}${imgbase}_bnw.vrt"
        imgfile="${img##*/}"
        imgbase="${imgfile%.*}"
        imgext="${imgfile##*.}"
    fi
    
    ##### get the xy size in pixels #####
    
    local x
    local y

    read x y < <(echo "$info" | grep -e "Size is"  | sed 's/Size is \([0-9]*\), \([0-9]*\)/\1 \2/' )

    
    ##### is the img too big? #####
    
    ((cutat=16384))
    
    if [[ $x -gt $cutat ]] || [[ $y -gt $cutat ]]
    then
        
        ##### loop over x #####

        local xsize
        local xoff

        ((xsize = $cutat))
        for ((xoff = 0; xoff < x; xoff += $cutat))
        do
            
            ##### set the x size of the sub img #####
            
            if ((xoff + xsize >= x))
            then
                ((xsize = x - xoff))
            fi
                
            ##### loop over y #####
            
            local ysize
            local yoff
            
            ((ysize = $cutat))
            for ((yoff = 0; yoff < y; yoff += $cutat))
            do
                
                ##### set the y size of the sub img #####
            
                if ((yoff + ysize >= y))
                then
                    ((ysize = y - yoff))
                fi

                local myislossy="$islossy"

#                ##### make sure if were in the center of the img we turn off islossy #####
#                
#                if [[ "$islossy" == "yes" ]] && \
#                   ((yoff > 0 )) && (( ysize + yoff < y )) && \
#                   ((xoff > 0 )) && (( xsize + xoff < x ))
#                then
#                    myislossy="no"
#                fi
                
                if [ -n "$ramdisk" ]
                then
                    local tmpram=$(mktemp -d -p "${ramdisk}" "${dsname}XXXXXXXXXX")
                else
                    local tmpram=$(mktemp -d -p "${tmpdir}" "${dsname}XXXXXXXXXX")
                fi
                
                ##### translate #####
                
                if [[ "$imgextlower" == "sid" ]]
                then

                    mrsiddecode -ulxy $xoff $yoff -wh \
                                $(($xoff + $xsize < $x ? $xsize + 1 : $xsize)) \
                                $(($yoff + $ysize < $y ? $ysize + 1 : $ysize)) \
                                -s 0 \
                                -i "${tmpdir}/${img}" \
                                -o "${tmpram}/${imgbase}_${xoff}_${yoff}.tif" > /dev/null || return

                    ##### mrsiddecode does not copy the srs if the srs is in a aux file so we need to copy it #####
                    
                    if grep -e "PROJCS.*\]\][^,]" <<< $info > /dev/null
                    then
                        gdal_translate -of VRT \
                                        -a_srs "$(sed s/'.*\(PROJCS.*\]\][^,]\).*/\1/' <<< $info)" \
                                        "${tmpram}/${imgbase}_${xoff}_${yoff}.tif" \
                                        "${tmpram}/${imgbase}_${xoff}_${yoff}.vrt" > /dev/null || return
                    else
                        echo "ERROR: no srs for ${tmpram}/${imgbase}_${xoff}_${yoff}.tif"
                        ls -l ${tmpram}/
                        rm -rf "$tmpram"
                        return
                    fi

                    dosubimg "${imgbase}_${xoff}_${yoff}.vrt" \
                             "$tmpram" "$ts" \
                             "$(gdalinfo "${tmpram}/${imgbase}_${xoff}_${yoff}.vrt")" \
                             "$myislossy" "no" || return
                    
                    ###### rm the tif #####

                    rm "${tmpram}/${imgbase}_${xoff}_${yoff}.tif"
                
                ##### if its ecw then use a tif for the temp step. libecw + nearblack = fail #####

                elif [[ "$imgextlower" == "ecw" ]] || [[ "$imgextlower" == "vrt" ]] && grep "${tmpdir}/${img}" -e "SourceFilename.*[.]ecw<" > /dev/null
                then
                    gdal_translate -srcwin $xoff $yoff \
                                   $(($xoff + $xsize < $x ? $xsize + 1 : $xsize)) \
                                   $(($yoff + $ysize < $y ? $ysize + 1 : $ysize)) \
                                   "${tmpdir}/${img}"\
                                   "${tmpram}/${imgbase}_${xoff}_${yoff}.tif" > /dev/null || return
            
                    dosubimg "${imgbase}_${xoff}_${yoff}.tif" \
                             "$tmpram" "$ts" \
                             "$(gdalinfo "${tmpram}/${imgbase}_${xoff}_${yoff}.tif")" \
                             "true" "no" || return
                
                ##### any other kind of image #####

                else
                    gdal_translate -of VRT -srcwin $xoff $yoff \
                                   $(($xoff + $xsize < $x ? $xsize + 1 : $xsize)) \
                                   $(($yoff + $ysize < $y ? $ysize + 1 : $ysize)) \
                                   "${tmpdir}/${img}"\
                                   "${tmpram}/${imgbase}_${xoff}_${yoff}.vrt" > /dev/null || return
            
                    dosubimg "${imgbase}_${xoff}_${yoff}.vrt" \
                             "$tmpram" "$ts" \
                             "$(gdalinfo "${tmpram}/${imgbase}_${xoff}_${yoff}.vrt")" \
                             "$myislossy" "no" || return
                fi
                
                rm -rf "$tmpram"

            done
        done
    
    ##### its not too big do the image as is #####
    
    else
    
        dosubimg "${img}" "$tmpdir" "$ts" \
                 "$info" "$islossy" "$isoriginal" || return
    fi

}

###############################################################################
# function rebuild the tile indexes for a ds
###############################################################################

function rebuildtindexs {

    ##### remove the old tindexs #####
    
    for shp in $(find ${outdir} -name "${dsname}[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9].shp")
    do
        local base="${shp%.*}"
        for ext in shp dbf prj shx
        do
            rm "${base}.${ext}"
        done
    done
    
    ##### make the new tindexs #####
    
    for img in $(find ${outdir} -iname "*.tif")
    do
        local imgfile="${img##*/}"
        local ts=$( sed 's:.*/\([0-9]\{8\}\).*:\1:' <<<"$img")
        local imgfile=$( sed "s:.*/$ts/\(.*\):\1:" <<<"$img")
        if [[ "$imgfile" != overview* ]]
        then
            
            ##### make the tileindex in a subshell so we can cd with no adverse effect #####
            ##### this costs like 2s of system time per 4000 calls #####

           (
               cd ${outdir}
               gdaltindex "${dsname}${ts}.shp" "${ts}/${imgfile}"  > /dev/null
           )
        fi
    done
}

###############################################################################
# function to do a multiband image
###############################################################################

function doimg_multiband {

    local base="$1"
    local tmpdir="$2"
    local ts="$3"
    local isoriginal="$4"
    local panfile="$5"
    local files=("${@:6}")
    
    if [ -n "$DEBUG_doimg_multiband" ]
    then
    printf " base=%s\n tmpdir=%s\n ts=%s\n isoriginal=%s\n panfile=%s\n files=%s\n" \
           "$base" \
           "$tmpdir" \
           "$ts" \
           "$isoriginal" \
           "$panfile" \
           "$files"
        return
    fi
    
    ##### make an array of the files with tmpdir prefixed #####
    
    local f
    local i
    local bands
    for f in "${files[@]}"
    do
        bands[i++]="${tmpdir}/$f"
    done
    
    ##### do we need a nodata value? #####
    
    if [ -n "$srcnodata" ]
    then
        local nodata=( -srcnodata "$srcnodata" )
    fi
    
    ##### make a vrt of the ms bands first ######
    
    
    gdalbuildvrt ${nodata[@]} -separate \
                 "${tmpdir}/${base}.vrt" \
                 ${bands[@]} > /dev/null || return
    
    local type=$(gdalinfo "${tmpdir}/${base}.vrt" | grep "Type=" | sed 's/.*Type=\(\w*\).*/\1/' | head -n 1)
    
    ##### fillnodata ? #####
    
    if istrue "$fillnodata"
    then
        
        ##### assume a max distance of 12 for landsat 7 #####
        
        if ! [ -n "$fillnodata_md" ]
        then
            local fillnodata_md=12
        fi
        
        ##### loop over the bands and fill them #####
        
        local i=0
        for f in "${files[@]}"
        do
            
            bands[i++]="${tmpdir}/${base}_$(($i + 1))_filled.tif"
            
            CPL_TMPDIR="$tmpdir" gdal_fillnodata.py -md $fillnodata_md \
                                                    -b $i \
                                                    "${tmpdir}/${base}.vrt" \
                                                    "${tmpdir}/${base}_${i}_filled.tif" > /dev/null || return

        done
        
        ##### make a vrt of the filled ms bands #####
        
        gdalbuildvrt -srcnodata 0 -separate \
                     "${tmpdir}/${base}.vrt" \
                     ${bands[@]} > /dev/null || return
        
        ##### fixme need to fill the pan band #####
        
    fi
    
    ##### cloud masking? #####
    
    if [ -n "$cloudmask" ]
    then
        
        "${#cloudmask[@]}"
        
        otbCloudMask "${tmpdir}/${base}.vrt" \
                     "${tmpdir}/${base}_cloudmask.tif" \
                     "${#cloudmask[@]}" \
                     ${cloudmask[@]} \
                     .2 .75 1
                     
        
    fi
    
    ##### do we pansharpen? #####
    
    if [ -n "$panfile" ]
    then
        
        ##### get the pix size of the pan image #####
        ##### this don't seem to work with gaps, the gaps in the pan band arent filled #####
        ##### mayby with cloud masking and multiple images it will be worth doing #####
        
        local pan_xsize
        local pan_ysize

        read pan_xsize pan_ysize < <(get_size "${tmpdir}/$panfile")
        
        gdal_translate -of VRT -outsize $pan_xsize $pan_ysize \
                       "${tmpdir}/${base}.vrt" \
                       "${tmpdir}/${base}_resize.vrt" > /dev/null || return
        
        otbPanSharp "$type" \
                    "${tmpdir}/$panfile" \
                    "${tmpdir}/${base}_resize.vrt" \
                    "${tmpdir}/${base}_pan.tif" > /dev/null || return
        
        ##### build a vrt just to keep the same filename  for consistency #####
        
        gdal_translate -of VRT \
                       "${tmpdir}/${base}_pan.tif" \
                       "${tmpdir}/${base}.vrt" > /dev/null || return
        
    fi
    
    ##### rescale the image #####

    if [ -n "$rescale" ]
    then
        ##### rename the source vrt so the output vrt will have the same filename for consistency #####
        
        mv "${tmpdir}/${base}.vrt" "${tmpdir}/${base}_prescale.vrt"
        
        gdal_translate -ot byte -scale $rescale -of VRT \
                       "${tmpdir}/${base}_prescale.vrt" \
                       "${tmpdir}/${base}.vrt" > /dev/null || return
    fi
    
    ##### do a washout nearblack to remove ms band staggering artefacts? #####
    
    if [[ "$type" != "Byte" ]] && ! [ -n "$nearwhite" ]
    then
        
        ##### fixme need to generate the -colors based on how many bands there are #####
        
        nearblack -color 0,0,0 -color 255,0,0 -color 0,255,0 -color 0,0,255 \
                  -color 0,255,255 -color 255,0,255 -color 255,255,0 \
                  -near 0 -nb 0 -setalpha -of gtiff \
                  "${tmpdir}/${base}_prescale.vrt" \
                  -o "${tmpdir}/${base}_wash.tif" > /dev/null || return
        
        ##### rename the source vrt so the output vrt will have the same filename for consistency #####
        
        mv "${tmpdir}/${base}.vrt" "${tmpdir}/${base}_prewashout.vrt"
        
        ##### loop over the ms bands and make a seperate vrt for each one #####
        
        local i=0
        for f in "${files[@]}"
        do
            bands[i++]="${tmpdir}/${base}_$(($i + 1)).vrt"
            gdal_translate -b $i -of VRT \
                           "${tmpdir}/${base}_prewashout.vrt" \
                           "${tmpdir}/${base}_${i}.vrt" > /dev/null || return
        done
        
        ##### make a vrt for the alpha band #####
        
        gdal_translate -b "${#files[@]}" -of VRT \
                       "${tmpdir}/${base}_wash.tif" \
                       "${tmpdir}/${base}_wash.vrt" > /dev/null || return
        
        ##### combine all the bands into a single vrt #####
        
        gdalbuildvrt -separate \
                     "${tmpdir}/${base}_sep.vrt" \
                     ${bands[@]} \
                     "${tmpdir}/${base}_wash.vrt" > /dev/null || return
        
        ##### rework the vrt to rgba #####
        
        sed "${tmpdir}/${base}_sep.vrt" \
            -e 's,\(band=\"1\".*>\),\1\n    <ColorInterp>Red</ColorInterp>,' \
            -e 's,\(band=\"2\".*>\),\1\n    <ColorInterp>Green</ColorInterp>,' \
            -e 's,\(band=\"3\".*>\),\1\n    <ColorInterp>Blue</ColorInterp>,' \
            -e 's,\(band=\"4\".*>\),\1\n    <ColorInterp>Alpha</ColorInterp>,' > "${tmpdir}/${base}.vrt"
            
    fi
    
    doimg "${base}.vrt" \
          "$tmpdir" \
          "$ts" \
          "$(gdalinfo "${tmpdir}/${base}.vrt")" \
          "no" || return
    
}


